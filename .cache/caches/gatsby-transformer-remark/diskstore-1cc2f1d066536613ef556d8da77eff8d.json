{"expireTime":9007200911206587000,"key":"transformer-remark-markdown-html-7bde50b55d32b2f06ca7eb5fe23ead2b-gatsby-remark-prismjs-","val":"<h2>Modules: CommonJS modules<a href=\"https://nodejs.org/api/modules.html#modules_modules_commonjs_modules\">#</a></h2>\n<p><a href=\"https://nodejs.org/api/documentation.html#documentation_stability_index\">Stability: 2</a> - Stable</p>\n<p>In the Node.js module system, each file is treated as a separate module. For example, consider a file named <code class=\"language-text\">foo.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const circle = require('./circle.js');\nconsole.log(`The area of a circle of radius 4 is ${circle.area(4)}`);</code></pre></div>\n<p>On the first line, <code class=\"language-text\">foo.js</code> loads the module <code class=\"language-text\">circle.js</code> that is in the same directory as <code class=\"language-text\">foo.js</code>.</p>\n<p>Here are the contents of <code class=\"language-text\">circle.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { PI } = Math;\n\nexports.area = (r) => PI * r ** 2;\n\nexports.circumference = (r) => 2 * PI * r;</code></pre></div>\n<p>The module <code class=\"language-text\">circle.js</code> has exported the functions <code class=\"language-text\">area()</code> and <code class=\"language-text\">circumference()</code>. Functions and objects are added to the root of a module by specifying additional properties on the special <code class=\"language-text\">exports</code> object.</p>\n<p>Variables local to the module will be private, because the module is wrapped in a function by Node.js (see <a href=\"https://nodejs.org/api/modules.html#modules_the_module_wrapper\">module wrapper</a>). In this example, the variable <code class=\"language-text\">PI</code> is private to <code class=\"language-text\">circle.js</code>.</p>\n<p>The <code class=\"language-text\">module.exports</code> property can be assigned a new value (such as a function or object).</p>\n<p>Below, <code class=\"language-text\">bar.js</code> makes use of the <code class=\"language-text\">square</code> module, which exports a Square class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Square = require('./square.js');\nconst mySquare = new Square(2);\nconsole.log(`The area of mySquare is ${mySquare.area()}`);</code></pre></div>\n<p>The <code class=\"language-text\">square</code> module is defined in <code class=\"language-text\">square.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Assigning to exports will not modify module, must use module.exports\nmodule.exports = class Square {\n  constructor(width) {\n    this.width = width;\n  }\n\n  area() {\n    return this.width ** 2;\n  }\n};</code></pre></div>\n<p>The module system is implemented in the <code class=\"language-text\">require('module')</code> module.</p>\n<h3>Accessing the main module<a href=\"https://nodejs.org/api/modules.html#modules_accessing_the_main_module\">#</a></h3>\n<p>When a file is run directly from Node.js, <code class=\"language-text\">require.main</code> is set to its <code class=\"language-text\">module</code>. That means that it is possible to determine whether a file has been run directly by testing <code class=\"language-text\">require.main === module</code>.</p>\n<p>For a file <code class=\"language-text\">foo.js</code>, this will be <code class=\"language-text\">true</code> if run via <code class=\"language-text\">node foo.js</code>, but <code class=\"language-text\">false</code> if run by <code class=\"language-text\">require('./foo')</code>.</p>\n<p>Because <code class=\"language-text\">module</code> provides a <code class=\"language-text\">filename</code> property (normally equivalent to <code class=\"language-text\">__filename</code>), the entry point of the current application can be obtained by checking <code class=\"language-text\">require.main.filename</code>.</p>\n<h3>Package manager tips<a href=\"https://nodejs.org/api/modules.html#modules_package_manager_tips\">#</a></h3>\n<p>The semantics of the Node.js <code class=\"language-text\">require()</code> function were designed to be general enough to support reasonable directory structures. Package manager programs such as <code class=\"language-text\">dpkg</code>, <code class=\"language-text\">rpm</code>, and <code class=\"language-text\">npm</code> will hopefully find it possible to build native packages from Node.js modules without modification.</p>\n<p>Below we give a suggested directory structure that could work:</p>\n<p>Let's say that we wanted to have the folder at <code class=\"language-text\">/usr/lib/node/&lt;some-package>/&lt;some-version></code> hold the contents of a specific version of a package.</p>\n<p>Packages can depend on one another. In order to install package <code class=\"language-text\">foo</code>, it may be necessary to install a specific version of package <code class=\"language-text\">bar</code>. The <code class=\"language-text\">bar</code> package may itself have dependencies, and in some cases, these may even collide or form cyclic dependencies.</p>\n<p>Because Node.js looks up the <code class=\"language-text\">realpath</code> of any modules it loads (that is, it resolves symlinks) and then <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">looks for their dependencies in <code class=\"language-text\">node_modules</code> folders</a>, this situation can be resolved with the following architecture:</p>\n<ul>\n<li><code class=\"language-text\">/usr/lib/node/foo/1.2.3/</code>: Contents of the <code class=\"language-text\">foo</code> package, version 1.2.3.</li>\n<li><code class=\"language-text\">/usr/lib/node/bar/4.3.2/</code>: Contents of the <code class=\"language-text\">bar</code> package that <code class=\"language-text\">foo</code> depends on.</li>\n<li><code class=\"language-text\">/usr/lib/node/foo/1.2.3/node_modules/bar</code>: Symbolic link to <code class=\"language-text\">/usr/lib/node/bar/4.3.2/</code>.</li>\n<li><code class=\"language-text\">/usr/lib/node/bar/4.3.2/node_modules/*</code>: Symbolic links to the packages that <code class=\"language-text\">bar</code> depends on.</li>\n</ul>\n<p>Thus, even if a cycle is encountered, or if there are dependency conflicts, every module will be able to get a version of its dependency that it can use.</p>\n<p>When the code in the <code class=\"language-text\">foo</code> package does <code class=\"language-text\">require('bar')</code>, it will get the version that is symlinked into <code class=\"language-text\">/usr/lib/node/foo/1.2.3/node_modules/bar</code>. Then, when the code in the <code class=\"language-text\">bar</code> package calls <code class=\"language-text\">require('quux')</code>, it'll get the version that is symlinked into <code class=\"language-text\">/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>\n<p>Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in <code class=\"language-text\">/usr/lib/node</code>, we could put them in <code class=\"language-text\">/usr/lib/node_modules/&lt;name>/&lt;version></code>. Then Node.js will not bother looking for missing dependencies in <code class=\"language-text\">/usr/node_modules</code> or <code class=\"language-text\">/node_modules</code>.</p>\n<p>In order to make modules available to the Node.js REPL, it might be useful to also add the <code class=\"language-text\">/usr/lib/node_modules</code> folder to the <code class=\"language-text\">$NODE_PATH</code> environment variable. Since the module lookups using <code class=\"language-text\">node_modules</code> folders are all relative, and based on the real path of the files making the calls to <code class=\"language-text\">require()</code>, the packages themselves can be anywhere.</p>\n<h3>The <code class=\"language-text\">.mjs</code> extension<a href=\"https://nodejs.org/api/modules.html#modules_the_mjs_extension\">#</a></h3>\n<p>It is not possible to <code class=\"language-text\">require()</code> files that have the <code class=\"language-text\">.mjs</code> extension. Attempting to do so will throw <a href=\"https://nodejs.org/api/errors.html#errors_err_require_esm\">an error</a>. The <code class=\"language-text\">.mjs</code> extension is reserved for <a href=\"https://nodejs.org/api/esm.html\">ECMAScript Modules</a> which cannot be loaded via <code class=\"language-text\">require()</code>. See <a href=\"https://nodejs.org/api/esm.html\">ECMAScript Modules</a> for more details.</p>\n<h3>All together...<a href=\"https://nodejs.org/api/modules.html#modules_all_together\">#</a></h3>\n<p>To get the exact filename that will be loaded when <code class=\"language-text\">require()</code> is called, use the <code class=\"language-text\">require.resolve()</code> function.</p>\n<p>Putting together all of the above, here is the high-level algorithm in pseudocode of what <code class=\"language-text\">require()</code> does:</p>\n<p>require(X) from module at path Y</p>\n<ol>\n<li>If X is a core module,\na. return the core module\nb. STOP</li>\n<li>If X begins with '/'\na. set Y to be the filesystem root</li>\n<li>If X begins with './' or '/' or '../'\na. LOAD<em>AS</em>FILE(Y + X)\nb. LOAD<em>AS</em>DIRECTORY(Y + X)\nc. THROW \"not found\"</li>\n<li>If X begins with '#'\na. LOAD<em>PACKAGE</em>IMPORTS(X, dirname(Y))</li>\n<li>LOAD<em>PACKAGE</em>SELF(X, dirname(Y))</li>\n<li>LOAD<em>NODE</em>MODULES(X, dirname(Y))</li>\n<li>THROW \"not found\"</li>\n</ol>\n<p>LOAD<em>AS</em>FILE(X)</p>\n<ol>\n<li>If X is a file, load X as its file extension format. STOP</li>\n<li>If X.js is a file, load X.js as JavaScript text. STOP</li>\n<li>If X.json is a file, parse X.json to a JavaScript Object. STOP</li>\n<li>If X.node is a file, load X.node as binary addon. STOP</li>\n</ol>\n<p>LOAD_INDEX(X)</p>\n<ol>\n<li>If X/index.js is a file, load X/index.js as JavaScript text. STOP</li>\n<li>If X/index.json is a file, parse X/index.json to a JavaScript object. STOP</li>\n<li>If X/index.node is a file, load X/index.node as binary addon. STOP</li>\n</ol>\n<p>LOAD<em>AS</em>DIRECTORY(X)</p>\n<ol>\n<li>If X/package.json is a file,\na. Parse X/package.json, and look for \"main\" field.\nb. If \"main\" is a falsy value, GOTO 2.\nc. let M = X + (json main field)\nd. LOAD<em>AS</em>FILE(M)\ne. LOAD<em>INDEX(M)\nf. LOAD</em>INDEX(X) DEPRECATED\ng. THROW \"not found\"</li>\n<li>LOAD_INDEX(X)</li>\n</ol>\n<p>LOAD<em>NODE</em>MODULES(X, START)</p>\n<ol>\n<li>let DIRS = NODE<em>MODULES</em>PATHS(START)</li>\n<li>for each DIR in DIRS:\na. LOAD<em>PACKAGE</em>EXPORTS(X, DIR)\nb. LOAD<em>AS</em>FILE(DIR/X)\nc. LOAD<em>AS</em>DIRECTORY(DIR/X)</li>\n</ol>\n<p>NODE<em>MODULES</em>PATHS(START)</p>\n<ol>\n<li>let PARTS = path split(START)</li>\n<li>let I = count of PARTS - 1</li>\n<li>let DIRS = [GLOBAL_FOLDERS]</li>\n<li>while I >= 0,\na. if PARTS[I] = \"node<em>modules\" CONTINUE\nb. DIR = path join(PARTS[0 .. I] + \"node</em>modules\")\nc. DIRS = DIRS + DIR\nd. let I = I - 1</li>\n<li>return DIRS</li>\n</ol>\n<p>LOAD<em>PACKAGE</em>IMPORTS(X, DIR)</p>\n<ol>\n<li>Find the closest package scope SCOPE to DIR.</li>\n<li>If no scope was found, return.</li>\n<li>If the SCOPE/package.json \"imports\" is null or undefined, return.</li>\n<li>let MATCH = PACKAGE<em>IMPORTS</em>RESOLVE(X, pathToFileURL(SCOPE),\n[\"node\", \"require\"]) <a href=\"https://nodejs.org/api/esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>.</li>\n<li>RESOLVE<em>ESM</em>MATCH(MATCH).</li>\n</ol>\n<p>LOAD<em>PACKAGE</em>EXPORTS(X, DIR)</p>\n<ol>\n<li>Try to interpret X as a combination of NAME and SUBPATH where the name\nmay have a @scope/ prefix and the subpath begins with a slash (<code class=\"language-text\">/</code>).</li>\n<li>If X does not match this pattern or DIR/NAME/package.json is not a file,\nreturn.</li>\n<li>Parse DIR/NAME/package.json, and look for \"exports\" field.</li>\n<li>If \"exports\" is null or undefined, return.</li>\n<li>let MATCH = PACKAGE<em>EXPORTS</em>RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n<code class=\"language-text\">package.json</code> \"exports\", [\"node\", \"require\"]) <a href=\"https://nodejs.org/api/esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>.</li>\n<li>RESOLVE<em>ESM</em>MATCH(MATCH)</li>\n</ol>\n<p>LOAD<em>PACKAGE</em>SELF(X, DIR)</p>\n<ol>\n<li>Find the closest package scope SCOPE to DIR.</li>\n<li>If no scope was found, return.</li>\n<li>If the SCOPE/package.json \"exports\" is null or undefined, return.</li>\n<li>If the SCOPE/package.json \"name\" is not the first segment of X, return.</li>\n<li>let MATCH = PACKAGE<em>EXPORTS</em>RESOLVE(pathToFileURL(SCOPE),\n\".\" + X.slice(\"name\".length), <code class=\"language-text\">package.json</code> \"exports\", [\"node\", \"require\"])\n<a href=\"https://nodejs.org/api/esm.md#resolver-algorithm-specification\">defined in the ESM resolver</a>.</li>\n<li>RESOLVE<em>ESM</em>MATCH(MATCH)</li>\n</ol>\n<p>RESOLVE<em>ESM</em>MATCH(MATCH)</p>\n<ol>\n<li>let { RESOLVED, EXACT } = MATCH</li>\n<li>let RESOLVED_PATH = fileURLToPath(RESOLVED)</li>\n<li>If EXACT is true,\na. If the file at RESOLVED<em>PATH exists, load RESOLVED</em>PATH as its extension\nformat. STOP</li>\n<li>Otherwise, if EXACT is false,\na. LOAD<em>AS</em>FILE(RESOLVED<em>PATH)\nb. LOAD</em>AS<em>DIRECTORY(RESOLVED</em>PATH)</li>\n<li>THROW \"not found\"</li>\n</ol>\n<h3>Caching<a href=\"https://nodejs.org/api/modules.html#modules_caching\">#</a></h3>\n<p>Modules are cached after the first time they are loaded. This means (among other things) that every call to <code class=\"language-text\">require('foo')</code> will get exactly the same object returned, if it would resolve to the same file.</p>\n<p>Provided <code class=\"language-text\">require.cache</code> is not modified, multiple calls to <code class=\"language-text\">require('foo')</code> will not cause the module code to be executed multiple times. This is an important feature. With it, \"partially done\" objects can be returned, thus allowing transitive dependencies to be loaded even when they would cause cycles.</p>\n<p>To have a module execute code multiple times, export a function, and call that function.</p>\n<h4>Module caching caveats<a href=\"https://nodejs.org/api/modules.html#modules_module_caching_caveats\">#</a></h4>\n<p>Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from <code class=\"language-text\">node_modules</code> folders), it is not a <em>guarantee</em> that <code class=\"language-text\">require('foo')</code> will always return the exact same object, if it would resolve to different files.</p>\n<p>Additionally, on case-insensitive file systems or operating systems, different resolved filenames can point to the same file, but the cache will still treat them as different modules and will reload the file multiple times. For example, <code class=\"language-text\">require('./foo')</code> and <code class=\"language-text\">require('./FOO')</code> return two different objects, irrespective of whether or not <code class=\"language-text\">./foo</code> and <code class=\"language-text\">./FOO</code> are the same file.</p>\n<h3>Core modules<a href=\"https://nodejs.org/api/modules.html#modules_core_modules\">#</a></h3>\n<p>History</p>\n<p>Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation.</p>\n<p>The core modules are defined within the Node.js source and are located in the <code class=\"language-text\">lib/</code> folder.</p>\n<p>Core modules are always preferentially loaded if their identifier is passed to <code class=\"language-text\">require()</code>. For instance, <code class=\"language-text\">require('http')</code> will always return the built in HTTP module, even if there is a file by that name.</p>\n<p>Core modules can also be identified using the <code class=\"language-text\">node:</code> prefix, in which case it bypasses the <code class=\"language-text\">require</code> cache. For instance, <code class=\"language-text\">require('node:http')</code> will always return the built in HTTP module, even if there is <code class=\"language-text\">require.cache</code> entry by that name.</p>\n<h3>Cycles<a href=\"https://nodejs.org/api/modules.html#modules_cycles\">#</a></h3>\n<p>When there are circular <code class=\"language-text\">require()</code> calls, a module might not have finished executing when it is returned.</p>\n<p>Consider this situation:</p>\n<p><code class=\"language-text\">a.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('a starting');\nexports.done = false;\nconst b = require('./b.js');\nconsole.log('in a, b.done = %j', b.done);\nexports.done = true;\nconsole.log('a done');</code></pre></div>\n<p><code class=\"language-text\">b.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('b starting');\nexports.done = false;\nconst a = require('./a.js');\nconsole.log('in b, a.done = %j', a.done);\nexports.done = true;\nconsole.log('b done');</code></pre></div>\n<p><code class=\"language-text\">main.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('main starting');\nconst a = require('./a.js');\nconst b = require('./b.js');\nconsole.log('in main, a.done = %j, b.done = %j', a.done, b.done);</code></pre></div>\n<p>When <code class=\"language-text\">main.js</code> loads <code class=\"language-text\">a.js</code>, then <code class=\"language-text\">a.js</code> in turn loads <code class=\"language-text\">b.js</code>. At that point, <code class=\"language-text\">b.js</code> tries to load <code class=\"language-text\">a.js</code>. In order to prevent an infinite loop, an unfinished copy of the <code class=\"language-text\">a.js</code> exports object is returned to the <code class=\"language-text\">b.js</code> module. <code class=\"language-text\">b.js</code> then finishes loading, and its <code class=\"language-text\">exports</code> object is provided to the <code class=\"language-text\">a.js</code> module.</p>\n<p>By the time <code class=\"language-text\">main.js</code> has loaded both modules, they're both finished. The output of this program would thus be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ node main.js\nmain starting\na starting\nb starting\nin b, a.done = false\nb done\nin a, b.done = true\na done\nin main, a.done = true, b.done = true</code></pre></div>\n<p>Careful planning is required to allow cyclic module dependencies to work correctly within an application.</p>\n<h3>File modules<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">#</a></h3>\n<p>If the exact filename is not found, then Node.js will attempt to load the required filename with the added extensions: <code class=\"language-text\">.js</code>, <code class=\"language-text\">.json</code>, and finally <code class=\"language-text\">.node</code>.</p>\n<p><code class=\"language-text\">.js</code> files are interpreted as JavaScript text files, and <code class=\"language-text\">.json</code> files are parsed as JSON text files. <code class=\"language-text\">.node</code> files are interpreted as compiled addon modules loaded with <code class=\"language-text\">process.dlopen()</code>.</p>\n<p>A required module prefixed with <code class=\"language-text\">'/'</code> is an absolute path to the file. For example, <code class=\"language-text\">require('/home/marco/foo.js')</code> will load the file at <code class=\"language-text\">/home/marco/foo.js</code>.</p>\n<p>A required module prefixed with <code class=\"language-text\">'./'</code> is relative to the file calling <code class=\"language-text\">require()</code>. That is, <code class=\"language-text\">circle.js</code> must be in the same directory as <code class=\"language-text\">foo.js</code> for <code class=\"language-text\">require('./circle')</code> to find it.</p>\n<p>Without a leading <code class=\"language-text\">'/'</code>, <code class=\"language-text\">'./'</code>, or <code class=\"language-text\">'../'</code> to indicate a file, the module must either be a core module or is loaded from a <code class=\"language-text\">node_modules</code> folder.</p>\n<p>If the given path does not exist, <code class=\"language-text\">require()</code> will throw an <a href=\"https://nodejs.org/api/errors.html#errors_class_error\"><code class=\"language-text\">Error</code></a> with its <code class=\"language-text\">code</code> property set to <code class=\"language-text\">'MODULE_NOT_FOUND'</code>.</p>\n<h3>Folders as modules<a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">#</a></h3>\n<p>It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to those directories. There are three ways in which a folder may be passed to <code class=\"language-text\">require()</code> as an argument.</p>\n<p>The first is to create a <a href=\"https://nodejs.org/api/packages.html#packages_node_js_package_json_field_definitions\"><code class=\"language-text\">package.json</code></a> file in the root of the folder, which specifies a <code class=\"language-text\">main</code> module. An example <a href=\"https://nodejs.org/api/packages.html#packages_node_js_package_json_field_definitions\"><code class=\"language-text\">package.json</code></a> file might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{ \"name\" : \"some-library\",\n  \"main\" : \"./lib/some-library.js\" }</code></pre></div>\n<p>If this was in a folder at <code class=\"language-text\">./some-library</code>, then <code class=\"language-text\">require('./some-library')</code> would attempt to load <code class=\"language-text\">./some-library/lib/some-library.js</code>.</p>\n<p>This is the extent of the awareness of <code class=\"language-text\">package.json</code> files within Node.js.</p>\n<p>If there is no <a href=\"https://nodejs.org/api/packages.html#packages_node_js_package_json_field_definitions\"><code class=\"language-text\">package.json</code></a> file present in the directory, or if the <a href=\"https://nodejs.org/api/packages.html#packages_main\"><code class=\"language-text\">\"main\"</code></a> entry is missing or cannot be resolved, then Node.js will attempt to load an <code class=\"language-text\">index.js</code> or <code class=\"language-text\">index.node</code> file out of that directory. For example, if there was no <a href=\"https://nodejs.org/api/packages.html#packages_node_js_package_json_field_definitions\"><code class=\"language-text\">package.json</code></a> file in the previous example, then <code class=\"language-text\">require('./some-library')</code> would attempt to load:</p>\n<ul>\n<li><code class=\"language-text\">./some-library/index.js</code></li>\n<li><code class=\"language-text\">./some-library/index.node</code></li>\n</ul>\n<p>If these attempts fail, then Node.js will report the entire module as missing with the default error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error: Cannot find module 'some-library'</code></pre></div>\n<h3>Loading from <code class=\"language-text\">node_modules</code> folders<a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">#</a></h3>\n<p>If the module identifier passed to <code class=\"language-text\">require()</code> is not a <a href=\"https://nodejs.org/api/modules.html#modules_core_modules\">core</a> module, and does not begin with <code class=\"language-text\">'/'</code>, <code class=\"language-text\">'../'</code>, or <code class=\"language-text\">'./'</code>, then Node.js starts at the parent directory of the current module, and adds <code class=\"language-text\">/node_modules</code>, and attempts to load the module from that location. Node.js will not append <code class=\"language-text\">node_modules</code> to a path already ending in <code class=\"language-text\">node_modules</code>.</p>\n<p>If it is not found there, then it moves to the parent directory, and so on, until the root of the file system is reached.</p>\n<p>For example, if the file at <code class=\"language-text\">'/home/ry/projects/foo.js'</code> called <code class=\"language-text\">require('bar.js')</code>, then Node.js would look in the following locations, in this order:</p>\n<ul>\n<li><code class=\"language-text\">/home/ry/projects/node_modules/bar.js</code></li>\n<li><code class=\"language-text\">/home/ry/node_modules/bar.js</code></li>\n<li><code class=\"language-text\">/home/node_modules/bar.js</code></li>\n<li><code class=\"language-text\">/node_modules/bar.js</code></li>\n</ul>\n<p>This allows programs to localize their dependencies, so that they do not clash.</p>\n<p>It is possible to require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance <code class=\"language-text\">require('example-module/path/to/file')</code> would resolve <code class=\"language-text\">path/to/file</code> relative to where <code class=\"language-text\">example-module</code> is located. The suffixed path follows the same module resolution semantics.</p>\n<h3>Loading from the global folders<a href=\"https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders\">#</a></h3>\n<p>If the <code class=\"language-text\">NODE_PATH</code> environment variable is set to a colon-delimited list of absolute paths, then Node.js will search those paths for modules if they are not found elsewhere.</p>\n<p>On Windows, <code class=\"language-text\">NODE_PATH</code> is delimited by semicolons (<code class=\"language-text\">;</code>) instead of colons.</p>\n<p><code class=\"language-text\">NODE_PATH</code> was originally created to support loading modules from varying paths before the current <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">module resolution</a> algorithm was defined.</p>\n<p><code class=\"language-text\">NODE_PATH</code> is still supported, but is less necessary now that the Node.js ecosystem has settled on a convention for locating dependent modules. Sometimes deployments that rely on <code class=\"language-text\">NODE_PATH</code> show surprising behavior when people are unaware that <code class=\"language-text\">NODE_PATH</code> must be set. Sometimes a module's dependencies change, causing a different version (or even a different module) to be loaded as the <code class=\"language-text\">NODE_PATH</code> is searched.</p>\n<p>Additionally, Node.js will search in the following list of GLOBAL_FOLDERS:</p>\n<ul>\n<li>1: <code class=\"language-text\">$HOME/.node_modules</code></li>\n<li>2: <code class=\"language-text\">$HOME/.node_libraries</code></li>\n<li>3: <code class=\"language-text\">$PREFIX/lib/node</code></li>\n</ul>\n<p>Where <code class=\"language-text\">$HOME</code> is the user's home directory, and <code class=\"language-text\">$PREFIX</code> is the Node.js configured <code class=\"language-text\">node_prefix</code>.</p>\n<p>These are mostly for historic reasons.</p>\n<p>It is strongly encouraged to place dependencies in the local <code class=\"language-text\">node_modules</code> folder. These will be loaded faster, and more reliably.</p>\n<h3>The module wrapper<a href=\"https://nodejs.org/api/modules.html#modules_the_module_wrapper\">#</a></h3>\n<p>Before a module's code is executed, Node.js will wrap it with a function wrapper that looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function(exports, require, module, __filename, __dirname) {\n// Module code actually lives in here\n});</code></pre></div>\n<p>By doing this, Node.js achieves a few things:</p>\n<ul>\n<li>It keeps top-level variables (defined with <code class=\"language-text\">var</code>, <code class=\"language-text\">const</code> or <code class=\"language-text\">let</code>) scoped to the module rather than the global object.</li>\n<li>\n<p>It helps to provide some global-looking variables that are actually specific to the module, such as:</p>\n<ul>\n<li>The <code class=\"language-text\">module</code> and <code class=\"language-text\">exports</code> objects that the implementor can use to export values from the module.</li>\n<li>The convenience variables <code class=\"language-text\">__filename</code> and <code class=\"language-text\">__dirname</code>, containing the module's absolute filename and directory path.</li>\n</ul>\n</li>\n</ul>\n<h3>The module scope<a href=\"https://nodejs.org/api/modules.html#modules_the_module_scope\">#</a></h3>\n<h4><code class=\"language-text\">__dirname</code><a href=\"https://nodejs.org/api/modules.html#modules_dirname\">#</a></h4>\n<p>Added in: v0.1.27</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>The directory name of the current module. This is the same as the <a href=\"https://nodejs.org/api/path.html#path_path_dirname_path\"><code class=\"language-text\">path.dirname()</code></a> of the <a href=\"https://nodejs.org/api/modules.html#modules_filename\"><code class=\"language-text\">__filename</code></a>.</p>\n<p>Example: running <code class=\"language-text\">node example.js</code> from <code class=\"language-text\">/Users/mjr</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(__dirname);\n// Prints: /Users/mjr\nconsole.log(path.dirname(__filename));\n// Prints: /Users/mjr</code></pre></div>\n<h4><code class=\"language-text\">__filename</code><a href=\"https://nodejs.org/api/modules.html#modules_filename\">#</a></h4>\n<p>Added in: v0.0.1</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>The file name of the current module. This is the current module file's absolute path with symlinks resolved.</p>\n<p>For a main program this is not necessarily the same as the file name used in the command line.</p>\n<p>See <a href=\"https://nodejs.org/api/modules.html#modules_dirname\"><code class=\"language-text\">__dirname</code></a> for the directory name of the current module.</p>\n<p>Examples:</p>\n<p>Running <code class=\"language-text\">node example.js</code> from <code class=\"language-text\">/Users/mjr</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(__filename);\n// Prints: /Users/mjr/example.js\nconsole.log(__dirname);\n// Prints: /Users/mjr</code></pre></div>\n<p>Given two modules: <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code>, where <code class=\"language-text\">b</code> is a dependency of <code class=\"language-text\">a</code> and there is a directory structure of:</p>\n<ul>\n<li><code class=\"language-text\">/Users/mjr/app/a.js</code></li>\n<li><code class=\"language-text\">/Users/mjr/app/node_modules/b/b.js</code></li>\n</ul>\n<p>References to <code class=\"language-text\">__filename</code> within <code class=\"language-text\">b.js</code> will return <code class=\"language-text\">/Users/mjr/app/node_modules/b/b.js</code> while references to <code class=\"language-text\">__filename</code> within <code class=\"language-text\">a.js</code> will return <code class=\"language-text\">/Users/mjr/app/a.js</code>.</p>\n<h4><code class=\"language-text\">exports</code><a href=\"https://nodejs.org/api/modules.html#modules_exports\">#</a></h4>\n<p>Added in: v0.1.12</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n</ul>\n<p>A reference to the <code class=\"language-text\">module.exports</code> that is shorter to type. See the section about the <a href=\"https://nodejs.org/api/modules.html#modules_exports_shortcut\">exports shortcut</a> for details on when to use <code class=\"language-text\">exports</code> and when to use <code class=\"language-text\">module.exports</code>.</p>\n<h4><code class=\"language-text\">module</code><a href=\"https://nodejs.org/api/modules.html#modules_module\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\"><module></a></li>\n</ul>\n<p>A reference to the current module, see the section about the <a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\"><code class=\"language-text\">module</code> object</a>. In particular, <code class=\"language-text\">module.exports</code> is used for defining what a module exports and makes available through <code class=\"language-text\">require()</code>.</p>\n<h4><code class=\"language-text\">require(id)</code><a href=\"https://nodejs.org/api/modules.html#modules_require_id\">#</a></h4>\n<p>Added in: v0.1.13</p>\n<ul>\n<li><code class=\"language-text\">id</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a> module name or path</li>\n<li>Returns: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\"><any></a> exported module content</li>\n</ul>\n<p>Used to import modules, <code class=\"language-text\">JSON</code>, and local files. Modules can be imported from <code class=\"language-text\">node_modules</code>. Local modules and JSON files can be imported using a relative path (e.g. <code class=\"language-text\">./</code>, <code class=\"language-text\">./foo</code>, <code class=\"language-text\">./bar/baz</code>, <code class=\"language-text\">../foo</code>) that will be resolved against the directory named by <a href=\"https://nodejs.org/api/modules.html#modules_dirname\"><code class=\"language-text\">__dirname</code></a> (if defined) or the current working directory. The relative paths of POSIX style are resolved in an OS independent fashion, meaning that the examples above will work on Windows in the same way they would on Unix systems.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Importing a local module with a path relative to the `__dirname` or current\n// working directory. (On Windows, this would resolve to .\\path\\myLocalModule.)\nconst myLocalModule = require('./path/myLocalModule');\n\n// Importing a JSON file:\nconst jsonData = require('./path/filename.json');\n\n// Importing a module from node_modules or Node.js built-in module:\nconst crypto = require('crypto');</code></pre></div>\n<h5><code class=\"language-text\">require.cache</code><a href=\"https://nodejs.org/api/modules.html#modules_require_cache\">#</a></h5>\n<p>Added in: v0.3.0</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n</ul>\n<p>Modules are cached in this object when they are required. By deleting a key value from this object, the next <code class=\"language-text\">require</code> will reload the module. This does not apply to <a href=\"https://nodejs.org/api/addons.html\">native addons</a>, for which reloading will result in an error.</p>\n<p>Adding or replacing entries is also possible. This cache is checked before native modules and if a name matching a native module is added to the cache, only <code class=\"language-text\">node:</code>-prefixed require calls are going to receive the native module. Use with care!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const assert = require('assert');\nconst realFs = require('fs');\n\nconst fakeFs = {};\nrequire.cache.fs = { exports: fakeFs };\n\nassert.strictEqual(require('fs'), fakeFs);\nassert.strictEqual(require('node:fs'), realFs);</code></pre></div>\n<h5><code class=\"language-text\">require.extensions</code><a href=\"https://nodejs.org/api/modules.html#modules_require_extensions\">#</a></h5>\n<p>Added in: v0.3.0Deprecated since: v0.10.6</p>\n<p><a href=\"https://nodejs.org/api/documentation.html#documentation_stability_index\">Stability: 0</a> - Deprecated</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n</ul>\n<p>Instruct <code class=\"language-text\">require</code> on how to handle certain file extensions.</p>\n<p>Process files with the extension <code class=\"language-text\">.sjs</code> as <code class=\"language-text\">.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require.extensions['.sjs'] = require.extensions['.js'];</code></pre></div>\n<p>Deprecated. In the past, this list has been used to load non-JavaScript modules into Node.js by compiling them on-demand. However, in practice, there are much better ways to do this, such as loading modules via some other Node.js program, or compiling them to JavaScript ahead of time.</p>\n<p>Avoid using <code class=\"language-text\">require.extensions</code>. Use could cause subtle bugs and resolving the extensions gets slower with each registered extension.</p>\n<h5><code class=\"language-text\">require.main</code><a href=\"https://nodejs.org/api/modules.html#modules_require_main\">#</a></h5>\n<p>Added in: v0.1.17</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\"><module></a></li>\n</ul>\n<p>The <code class=\"language-text\">Module</code> object representing the entry script loaded when the Node.js process launched. See <a href=\"https://nodejs.org/api/modules.html#modules_accessing_the_main_module\">\"Accessing the main module\"</a>.</p>\n<p>In <code class=\"language-text\">entry.js</code> script:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(require.main);</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">node entry.js</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Module {\n  id: '.',\n  path: '/absolute/path/to',\n  exports: {},\n  filename: '/absolute/path/to/entry.js',\n  loaded: false,\n  children: [],\n  paths:\n   [ '/absolute/path/to/node_modules',\n     '/absolute/path/node_modules',\n     '/absolute/node_modules',\n     '/node_modules' ] }</code></pre></div>\n<h5><code class=\"language-text\">require.resolve(request[, options])</code><a href=\"https://nodejs.org/api/modules.html#modules_require_resolve_request_options\">#</a></h5>\n<p>History</p>\n<ul>\n<li><code class=\"language-text\">request</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a> The module path to resolve.</li>\n<li><code class=\"language-text\">options</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n<li>\n<ul>\n<li><code class=\"language-text\">paths</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\">&#x3C;string[]></a> Paths to resolve module location from. If present, these paths are used instead of the default resolution paths, with the exception of <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders\">GLOBAL_FOLDERS</a> like <code class=\"language-text\">$HOME/.node_modules</code>, which are always included. Each of these paths is used as a starting point for the module resolution algorithm, meaning that the <code class=\"language-text\">node_modules</code> hierarchy is checked from this location.</li>\n</ul>\n</li>\n<li>Returns: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>Use the internal <code class=\"language-text\">require()</code> machinery to look up the location of a module, but rather than loading the module, just return the resolved filename.</p>\n<p>If the module can not be found, a <code class=\"language-text\">MODULE_NOT_FOUND</code> error is thrown.</p>\n<h6><code class=\"language-text\">require.resolve.paths(request)</code><a href=\"https://nodejs.org/api/modules.html#modules_require_resolve_paths_request\">#</a></h6>\n<p>Added in: v8.9.0</p>\n<ul>\n<li><code class=\"language-text\">request</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a> The module path whose lookup paths are being retrieved.</li>\n<li>Returns: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\">&#x3C;string[]></a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type\"><null></a></li>\n</ul>\n<p>Returns an array containing the paths searched during resolution of <code class=\"language-text\">request</code> or <code class=\"language-text\">null</code> if the <code class=\"language-text\">request</code> string references a core module, for example <code class=\"language-text\">http</code> or <code class=\"language-text\">fs</code>.</p>\n<h3>The <code class=\"language-text\">module</code> object<a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\">#</a></h3>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n</ul>\n<p>In each module, the <code class=\"language-text\">module</code> free variable is a reference to the object representing the current module. For convenience, <code class=\"language-text\">module.exports</code> is also accessible via the <code class=\"language-text\">exports</code> module-global. <code class=\"language-text\">module</code> is not actually a global but rather local to each module.</p>\n<h4><code class=\"language-text\">module.children</code><a href=\"https://nodejs.org/api/modules.html#modules_module_children\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\">&#x3C;module[]></a></li>\n</ul>\n<p>The module objects required for the first time by this one.</p>\n<h4><code class=\"language-text\">module.exports</code><a href=\"https://nodejs.org/api/modules.html#modules_module_exports\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\"><Object></a></li>\n</ul>\n<p>The <code class=\"language-text\">module.exports</code> object is created by the <code class=\"language-text\">Module</code> system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to <code class=\"language-text\">module.exports</code>. Assigning the desired object to <code class=\"language-text\">exports</code> will simply rebind the local <code class=\"language-text\">exports</code> variable, which is probably not what is desired.</p>\n<p>For example, suppose we were making a module called <code class=\"language-text\">a.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const EventEmitter = require('events');\n\nmodule.exports = new EventEmitter();\n\n// Do some work, and after some time emit\n// the 'ready' event from the module itself.\nsetTimeout(() => {\n  module.exports.emit('ready');\n}, 1000);</code></pre></div>\n<p>Then in another file we could do:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const a = require('./a');\na.on('ready', () => {\n  console.log('module \"a\" is ready');\n});</code></pre></div>\n<p>Assignment to <code class=\"language-text\">module.exports</code> must be done immediately. It cannot be done in any callbacks. This does not work:</p>\n<p><code class=\"language-text\">x.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">setTimeout(() => {\n  module.exports = { a: 'hello' };\n}, 0);</code></pre></div>\n<p><code class=\"language-text\">y.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x = require('./x');\nconsole.log(x.a);</code></pre></div>\n<h5><code class=\"language-text\">exports</code> shortcut<a href=\"https://nodejs.org/api/modules.html#modules_exports_shortcut\">#</a></h5>\n<p>Added in: v0.1.16</p>\n<p>The <code class=\"language-text\">exports</code> variable is available within a module's file-level scope, and is assigned the value of <code class=\"language-text\">module.exports</code> before the module is evaluated.</p>\n<p>It allows a shortcut, so that <code class=\"language-text\">module.exports.f = ...</code> can be written more succinctly as <code class=\"language-text\">exports.f = ...</code>. However, be aware that like any variable, if a new value is assigned to <code class=\"language-text\">exports</code>, it is no longer bound to <code class=\"language-text\">module.exports</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module.exports.hello = true; // Exported from require of module\nexports = { hello: false };  // Not exported, only available in the module</code></pre></div>\n<p>When the <code class=\"language-text\">module.exports</code> property is being completely replaced by a new object, it is common to also reassign <code class=\"language-text\">exports</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module.exports = exports = function Constructor() {\n  // ... etc.\n};</code></pre></div>\n<p>To illustrate the behavior, imagine this hypothetical implementation of <code class=\"language-text\">require()</code>, which is quite similar to what is actually done by <code class=\"language-text\">require()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function require(/* ... */) {\n  const module = { exports: {} };\n  ((module, exports) => {\n    // Module code here. In this example, define a function.\n    function someFunc() {}\n    exports = someFunc;\n    // At this point, exports is no longer a shortcut to module.exports, and\n    // this module will still export an empty default object.\n    module.exports = someFunc;\n    // At this point, the module will now export someFunc, instead of the\n    // default object.\n  })(module, module.exports);\n  return module.exports;\n}</code></pre></div>\n<h4><code class=\"language-text\">module.filename</code><a href=\"https://nodejs.org/api/modules.html#modules_module_filename\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>The fully resolved filename of the module.</p>\n<h4><code class=\"language-text\">module.id</code><a href=\"https://nodejs.org/api/modules.html#modules_module_id\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>The identifier for the module. Typically this is the fully resolved filename.</p>\n<h4><code class=\"language-text\">module.isPreloading</code><a href=\"https://nodejs.org/api/modules.html#modules_module_ispreloading\">#</a></h4>\n<p>Added in: v15.4.0</p>\n<ul>\n<li>Type: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type\"><boolean></a> <code class=\"language-text\">true</code> if the module is running during the Node.js preload phase.</li>\n</ul>\n<h4><code class=\"language-text\">module.loaded</code><a href=\"https://nodejs.org/api/modules.html#modules_module_loaded\">#</a></h4>\n<p>Added in: v0.1.16</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type\"><boolean></a></li>\n</ul>\n<p>Whether or not the module is done loading, or is in the process of loading.</p>\n<h4><code class=\"language-text\">module.parent</code><a href=\"https://nodejs.org/api/modules.html#modules_module_parent\">#</a></h4>\n<p>Added in: v0.1.16Deprecated since: v14.6.0, v12.19.0</p>\n<p><a href=\"https://nodejs.org/api/documentation.html#documentation_stability_index\">Stability: 0</a> - Deprecated: Please use <a href=\"https://nodejs.org/api/modules.html#modules_require_main\"><code class=\"language-text\">require.main</code></a> and <a href=\"https://nodejs.org/api/modules.html#modules_module_children\"><code class=\"language-text\">module.children</code></a> instead.</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/modules.html#modules_the_module_object\"><module></a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type\"><null></a> | <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type\"><undefined></a></li>\n</ul>\n<p>The module that first required this one, or <code class=\"language-text\">null</code> if the current module is the entry point of the current process, or <code class=\"language-text\">undefined</code> if the module was loaded by something that is not a CommonJS module (E.G.: REPL or <code class=\"language-text\">import</code>).</p>\n<h4><code class=\"language-text\">module.path</code><a href=\"https://nodejs.org/api/modules.html#modules_module_path\">#</a></h4>\n<p>Added in: v11.14.0</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n</ul>\n<p>The directory name of the module. This is usually the same as the <a href=\"https://nodejs.org/api/path.html#path_path_dirname_path\"><code class=\"language-text\">path.dirname()</code></a> of the <a href=\"https://nodejs.org/api/modules.html#modules_module_id\"><code class=\"language-text\">module.id</code></a>.</p>\n<h4><code class=\"language-text\">module.paths</code><a href=\"https://nodejs.org/api/modules.html#modules_module_paths\">#</a></h4>\n<p>Added in: v0.4.0</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\">&#x3C;string[]></a></li>\n</ul>\n<p>The search paths for the module.</p>\n<h4><code class=\"language-text\">module.require(id)</code><a href=\"https://nodejs.org/api/modules.html#modules_module_require_id\">#</a></h4>\n<p>Added in: v0.5.1</p>\n<ul>\n<li><code class=\"language-text\">id</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type\"><string></a></li>\n<li>Returns: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types\"><any></a> exported module content</li>\n</ul>\n<p>The <code class=\"language-text\">module.require()</code> method provides a way to load a module as if <code class=\"language-text\">require()</code> was called from the original module.</p>\n<p>In order to do this, it is necessary to get a reference to the <code class=\"language-text\">module</code> object. Since <code class=\"language-text\">require()</code> returns the <code class=\"language-text\">module.exports</code>, and the <code class=\"language-text\">module</code> is typically <em>only</em> available within a specific module's code, it must be explicitly exported in order to be used.</p>\n<h3>The <code class=\"language-text\">Module</code> object<a href=\"https://nodejs.org/api/modules.html#modules_the_module_object_1\">#</a></h3>\n<p>This section was moved to <a href=\"https://nodejs.org/api/module.html#module_the_module_object\">Modules: <code class=\"language-text\">module</code> core module</a>.</p>\n<ul>\n<li><a href=\"https://nodejs.org/api/module.html#module_module_builtinmodules\"><code class=\"language-text\">module.builtinModules</code></a></li>\n<li><a href=\"https://nodejs.org/api/module.html#module_module_createrequire_filename\"><code class=\"language-text\">module.createRequire(filename)</code></a></li>\n<li><a href=\"https://nodejs.org/api/module.html#module_module_syncbuiltinesmexports\"></a></li>\n</ul>"}