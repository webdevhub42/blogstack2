{"expireTime":9007200911870455000,"key":"transformer-remark-markdown-html-6a7fe14f92bab70584a3fbfea0fa2d55-gatsby-remark-prismjs-","val":"<h2>Git Reference</h2>\n<iframe style=\"resize:both; overflow:scroll;\"  sandbox=\"allow-scripts\" style=\"resize:both; overflow:scroll;\"    src=\"https://bgoonz.github.io/GIT_GUIDE_Bgoonz/\" height=\"800px\" width=\"1000px\" scrolling=\"yes\"   frameborder=\"yes\" loading=\"lazy\"  allowfullscreen=\"true\"  frameborder=\"0\" >\n</iframe>\n<br>\n<br>\n<br>\n<br>\n<p>Git is a distributed version control and source code management system.</p>\n<p>It does this through a series of snapshots of your project, and it works\nwith those snapshots to provide you with functionality to version and\nmanage your source code.</p>\n<h2>Versioning Concepts</h2>\n<h3>What is version control?</h3>\n<p>Version control is a system that records changes to a file(s), over time.</p>\n<h3>Centralized Versioning vs. Distributed Versioning</h3>\n<ul>\n<li>Centralized version control focuses on synchronizing, tracking, and backing</li>\n<li>up files.</li>\n<li>Distributed version control focuses on sharing changes. Every change has a\nunique id.</li>\n<li>Distributed systems have no defined structure. You could easily have a SVN\nstyle, centralized system, with git.</li>\n</ul>\n<p><a href=\"http://git-scm.com/book/en/Getting-Started-About-Version-Control\">Additional Information</a></p>\n<h3>Why Use Git?</h3>\n<ul>\n<li>Can work offline.</li>\n<li>Collaborating with others is easy!</li>\n<li>Branching is easy!</li>\n<li>Branching is fast!</li>\n<li>Merging is easy!</li>\n<li>Git is fast.</li>\n<li>Git is flexible.</li>\n</ul>\n<h2>Git Architecture</h2>\n<h3>Repository</h3>\n<p>A set of files, directories, historical records, commits, and heads. Imagine it\nas a source code data structure, with the attribute that each source code\n\"element\" gives you access to its revision history, among other things.</p>\n<p>A git repository is comprised of the .git directory &#x26; working tree.</p>\n<h3>.git Directory (component of repository)</h3>\n<p>The .git directory contains all the configurations, logs, branches, HEAD, and\nmore.\n<a href=\"http://gitready.com/advanced/2009/03/23/whats-inside-your-git-directory.html\">Detailed List.</a></p>\n<h3>Working Tree (component of repository)</h3>\n<p>This is basically the directories and files in your repository. It is often\nreferred to as your working directory.</p>\n<h3>Index (component of .git dir)</h3>\n<p>The Index is the staging area in git. It's basically a layer that separates\nyour working tree from the Git repository. This gives developers more power\nover what gets sent to the Git repository.</p>\n<h3>Commit</h3>\n<p>A git commit is a snapshot of a set of changes, or manipulations to your\nWorking Tree. For example, if you added 5 files, and removed 2 others, these\nchanges will be contained in a commit (or snapshot). This commit can then be\npushed to other repositories, or not!</p>\n<h3>Branch</h3>\n<p>A branch is essentially a pointer to the last commit you made. As you go on\ncommitting, this pointer will automatically update to point to the latest commit.</p>\n<h3>Tag</h3>\n<p>A tag is a mark on specific point in history. Typically people use this\nfunctionality to mark release points (v1.0, and so on).</p>\n<h3>HEAD and head (component of .git dir)</h3>\n<p>HEAD is a pointer that points to the current branch. A repository only has 1\n<em>active</em> HEAD.\nhead is a pointer that points to any commit. A repository can have any number\nof heads.</p>\n<h3>Stages of Git</h3>\n<ul>\n<li>Modified - Changes have been made to a file but file has not been committed</li>\n<li>to Git Database yet</li>\n<li>Staged - Marks a modified file to go into your next commit snapshot</li>\n<li>Committed - Files have been committed to the Git Database</li>\n</ul>\n<h3>Conceptual Resources</h3>\n<ul>\n<li><a href=\"http://eagain.net/articles/git-for-computer-scientists/\">Git For Computer Scientists</a></li>\n<li><a href=\"http://hoth.entp.com/output/git_for_designers.html\">Git For Designers</a></li>\n</ul>\n<h2>Commands</h2>\n<h3>init</h3>\n<p>Create an empty Git repository. The Git repository's settings, stored\ninformation, and more is stored in a directory (a folder) named \".git\".</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> init</code></pre></div>\n<h3>config</h3>\n<p>To configure settings. Whether it be for the repository, the system itself,\nor global configurations ( global config file is <code class=\"language-text\">~/.gitconfig</code> ).</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Print &amp; Set Some Basic Config Variables (Global)</span>\n <span class=\"token function\">git</span> config --global user.email <span class=\"token string\">\"bryan.guner@gmail.com\"</span>\n <span class=\"token function\">git</span> config --global user.name <span class=\"token string\">\"bryan\"</span></code></pre></div>\n<p><a href=\"http://git-scm.com/docs/git-config\">Learn More About git config.</a></p>\n<h3>help</h3>\n<p>To give you quick access to an extremely detailed guide of each command. Or to\njust give you a quick reminder of some semantics.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Quickly check available commands</span>\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span>\n\n<span class=\"token comment\"># Check all available commands</span>\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span> -a\n\n<span class=\"token comment\"># Command specific help - user manual</span>\n<span class=\"token comment\"># git help &lt;command_here></span>\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span> <span class=\"token function\">add</span>\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span> commit\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span> init\n<span class=\"token comment\"># or git &lt;command_here> --help</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> --help\n$ <span class=\"token function\">git</span> commit --help\n$ <span class=\"token function\">git</span> init --help</code></pre></div>\n<h3>ignore files</h3>\n<p>To intentionally untrack file(s) &#x26; folder(s) from git. Typically meant for\nprivate &#x26; temp files which would otherwise be shared in the repository.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"temp/\"</span> <span class=\"token operator\">>></span> .gitignore\n$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"private_key\"</span> <span class=\"token operator\">>></span> .gitignore</code></pre></div>\n<h3>status</h3>\n<p>To show differences between the index file (basically your working copy/repo)\nand the current HEAD commit.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Will display the branch, untracked files, changes and other differences</span>\n$ <span class=\"token function\">git</span> status\n\n<span class=\"token comment\"># To learn other \"tid bits\" about git status</span>\n$ <span class=\"token function\">git</span> <span class=\"token builtin class-name\">help</span> status</code></pre></div>\n<h3>add</h3>\n<p>To add files to the staging area/index. If you do not <code class=\"language-text\">git add</code> new files to\nthe staging area/index, they will not be included in commits!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># add a file in your current working directory</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> HelloWorld.java\n\n<span class=\"token comment\"># add a file in a nested dir</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> /path/to/file/HelloWorld.c\n\n<span class=\"token comment\"># Regular Expression support!</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> ./*.java\n\n<span class=\"token comment\"># You can also add everything in your working directory to the staging area.</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> -A</code></pre></div>\n<p>This only adds a file to the staging area/index, it doesn't commit it to the\nworking directory/repo.</p>\n<h3>branch</h3>\n<p>Manage your branches. You can view, edit, create, delete branches using this\ncommand.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># list existing branches &amp; remotes</span>\n$ <span class=\"token function\">git</span> branch -a\n\n<span class=\"token comment\"># create a new branch</span>\n$ <span class=\"token function\">git</span> branch myNewBranch\n\n<span class=\"token comment\"># delete a branch</span>\n$ <span class=\"token function\">git</span> branch -d myBranch\n\n<span class=\"token comment\"># rename a branch</span>\n<span class=\"token comment\"># git branch -m &lt;oldname> &lt;newname></span>\n$ <span class=\"token function\">git</span> branch -m myBranchName myNewBranchName\n\n<span class=\"token comment\"># edit a branch's description</span>\n$ <span class=\"token function\">git</span> branch myBranchName --edit-description</code></pre></div>\n<h3>tag</h3>\n<p>Manage your tags</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># List tags</span>\n$ <span class=\"token function\">git</span> tag\n\n<span class=\"token comment\"># Create a annotated tag</span>\n<span class=\"token comment\"># The -m specifies a tagging message, which is stored with the tag.</span>\n<span class=\"token comment\"># If you don't specify a message for an annotated tag,</span>\n<span class=\"token comment\"># Git launches your editor so you can type it in.</span>\n$ <span class=\"token function\">git</span> tag -a v2.0 -m <span class=\"token string\">'my version 2.0'</span>\n\n<span class=\"token comment\"># Show info about tag</span>\n<span class=\"token comment\"># That shows the tagger information, the date the commit was tagged,</span>\n<span class=\"token comment\"># and the annotation message before showing the commit information.</span>\n$ <span class=\"token function\">git</span> show v2.0\n\n<span class=\"token comment\"># Push a single tag to remote</span>\n$ <span class=\"token function\">git</span> push origin v2.0\n\n<span class=\"token comment\"># Push a lot of tags to remote</span>\n$ <span class=\"token function\">git</span> push origin --tags</code></pre></div>\n<h3>checkout</h3>\n<p>Updates all files in the working tree to match the version in the index, or\nspecified tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Checkout a repo - defaults to master branch</span>\n$ <span class=\"token function\">git</span> checkout\n\n<span class=\"token comment\"># Checkout a specified branch</span>\n$ <span class=\"token function\">git</span> checkout branchName\n\n<span class=\"token comment\"># Create a new branch &amp; switch to it</span>\n<span class=\"token comment\"># equivalent to \"git branch &lt;name>; git checkout &lt;name>\"</span>\n\n$ <span class=\"token function\">git</span> checkout -b newBranch</code></pre></div>\n<h3>clone</h3>\n<p>Clones, or copies, an existing repository into a new directory. It also adds\nremote-tracking branches for each branch in the cloned repo, which allows you\nto push to a remote branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Clone learnxinyminutes-docs</span>\n$ <span class=\"token function\">git</span> clone https://github.com/adambard/learnxinyminutes-docs.git\n\n<span class=\"token comment\"># shallow clone - faster cloning that pulls only latest snapshot</span>\n$ <span class=\"token function\">git</span> clone --depth <span class=\"token number\">1</span> https://github.com/adambard/learnxinyminutes-docs.git\n\n<span class=\"token comment\"># clone only a specific branch</span>\n$ <span class=\"token function\">git</span> clone -b master-cn https://github.com/adambard/learnxinyminutes-docs.git --single-branch</code></pre></div>\n<h3>commit</h3>\n<p>Stores the current contents of the index in a new \"commit.\" This commit\ncontains the changes made and a message created by the user.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># commit with a message</span>\n$ <span class=\"token function\">git</span> commit -m <span class=\"token string\">\"Added multiplyNumbers() function to HelloWorld.c\"</span>\n\n<span class=\"token comment\"># signed commit with a message (user.signingkey must have been set</span>\n<span class=\"token comment\"># with your GPG key e.g. git config --global user.signingkey 5173AAD5)</span>\n$ <span class=\"token function\">git</span> commit -S -m <span class=\"token string\">\"signed commit message\"</span>\n\n<span class=\"token comment\"># automatically stage modified or deleted files, except new files, and then commit</span>\n$ <span class=\"token function\">git</span> commit -a -m <span class=\"token string\">\"Modified foo.php and removed bar.php\"</span>\n\n<span class=\"token comment\"># change last commit (this deletes previous commit with a fresh commit)</span>\n$ <span class=\"token function\">git</span> commit --amend -m <span class=\"token string\">\"Correct message\"</span></code></pre></div>\n<h3>diff</h3>\n<p>Shows differences between a file in the working directory, index and commits.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Show difference between your working dir and the index</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span>\n\n<span class=\"token comment\"># Show differences between the index and the most recent commit.</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> --cached\n\n<span class=\"token comment\"># Show differences between your working dir and the most recent commit</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> HEAD</code></pre></div>\n<h3>grep</h3>\n<p>Allows you to quickly search a repository.</p>\n<p>Optional Configurations:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Thanks to Travis Jeffery for these</span>\n<span class=\"token comment\"># Set line numbers to be shown in grep search results</span>\n$ <span class=\"token function\">git</span> config --global grep.lineNumber <span class=\"token boolean\">true</span>\n\n<span class=\"token comment\"># Make search results more readable, including grouping</span>\n$ <span class=\"token function\">git</span> config --global alias.g <span class=\"token string\">\"grep --break --heading --line-number\"</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Search for \"variableName\" in all java files</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">grep</span> <span class=\"token string\">'variableName'</span> -- <span class=\"token string\">'*.java'</span>\n\n<span class=\"token comment\"># Search for a line that contains \"arrayListName\" and, \"add\" or \"remove\"</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">grep</span> -e <span class=\"token string\">'arrayListName'</span> --and <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">(</span> -e <span class=\"token function\">add</span> -e remove <span class=\"token punctuation\">\\</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Google is your friend; for more examples\n<a href=\"http://travisjeffery.com/b/2012/02/search-a-git-repo-like-a-ninja\">Git Grep Ninja</a></p>\n<h3>log</h3>\n<p>Display commits to the repository.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Show all commits</span>\n$ <span class=\"token function\">git</span> log\n\n<span class=\"token comment\"># Show only commit message &amp; ref</span>\n$ <span class=\"token function\">git</span> log --oneline\n\n<span class=\"token comment\"># Show merge commits only</span>\n$ <span class=\"token function\">git</span> log --merges\n\n<span class=\"token comment\"># Show all commits represented by an ASCII graph</span>\n$ <span class=\"token function\">git</span> log --graph</code></pre></div>\n<h3>merge</h3>\n<p>\"Merge\" in changes from external commits into the current branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Merge the specified branch into the current.</span>\n$ <span class=\"token function\">git</span> merge branchName\n\n<span class=\"token comment\"># Always generate a merge commit when merging</span>\n$ <span class=\"token function\">git</span> merge --no-ff branchName</code></pre></div>\n<h3>mv</h3>\n<p>Rename or move a file</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Renaming a file</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">mv</span> HelloWorld.c HelloNewWorld.c\n\n<span class=\"token comment\"># Moving a file</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">mv</span> HelloWorld.c ./new/path/HelloWorld.c\n\n<span class=\"token comment\"># Force rename or move</span>\n<span class=\"token comment\"># \"existingFile\" already exists in the directory, will be overwritten</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">mv</span> -f myFile existingFile</code></pre></div>\n<h3>pull</h3>\n<p>Pulls from a repository and merges it with another branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Update your local repo, by merging in new changes</span>\n<span class=\"token comment\"># from the remote \"origin\" and \"master\" branch.</span>\n<span class=\"token comment\"># git pull &lt;remote> &lt;branch></span>\n$ <span class=\"token function\">git</span> pull origin master\n\n<span class=\"token comment\"># By default, git pull will update your current branch</span>\n<span class=\"token comment\"># by merging in new changes from its remote-tracking branch</span>\n$ <span class=\"token function\">git</span> pull\n\n<span class=\"token comment\"># Merge in changes from remote branch and rebase</span>\n<span class=\"token comment\"># branch commits onto your local repo, like: \"git fetch &lt;remote> &lt;branch>, git</span>\n<span class=\"token comment\"># rebase &lt;remote>/&lt;branch>\"</span>\n$ <span class=\"token function\">git</span> pull origin master --rebase</code></pre></div>\n<h3>push</h3>\n<p>Push and merge changes from a branch to a remote &#x26; branch.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Push and merge changes from a local repo to a</span>\n<span class=\"token comment\"># remote named \"origin\" and \"master\" branch.</span>\n<span class=\"token comment\"># git push &lt;remote> &lt;branch></span>\n$ <span class=\"token function\">git</span> push origin master\n\n<span class=\"token comment\"># By default, git push will push and merge changes from</span>\n<span class=\"token comment\"># the current branch to its remote-tracking branch</span>\n$ <span class=\"token function\">git</span> push\n\n<span class=\"token comment\"># To link up current local branch with a remote branch, add -u flag:</span>\n$ <span class=\"token function\">git</span> push -u origin master\n<span class=\"token comment\"># Now, anytime you want to push from that same local branch, use shortcut:</span>\n$ <span class=\"token function\">git</span> push</code></pre></div>\n<h3>stash</h3>\n<p>Stashing takes the dirty state of your working directory and saves it on a\nstack of unfinished changes that you can reapply at any time.</p>\n<p>Let's say you've been doing some work in your git repo, but you want to pull\nfrom the remote. Since you have dirty (uncommitted) changes to some files, you\nare not able to run <code class=\"language-text\">git pull</code>. Instead, you can run <code class=\"language-text\">git stash</code> to save your\nchanges onto a stack!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> stash\nSaved working directory and index state <span class=\"token punctuation\">\\</span>\n  <span class=\"token string\">\"WIP on master: 049d078 added the index file\"</span>\n  HEAD is now at 049d078 added the index <span class=\"token function\">file</span>\n  <span class=\"token punctuation\">(</span>To restore them <span class=\"token builtin class-name\">type</span> <span class=\"token string\">\"git stash apply\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now you can pull!</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> pull</code></pre></div>\n<p><code class=\"language-text\">...changes apply...</code></p>\n<p>Now check that everything is OK</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> status\n<span class=\"token comment\"># On branch master</span>\nnothing to commit, working directory clean</code></pre></div>\n<p>You can see what \"hunks\" you've stashed so far using <code class=\"language-text\">git stash list</code>.\nSince the \"hunks\" are stored in a Last-In-First-Out stack, our most recent\nchange will be at top.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> stash list\nstash@<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span>: WIP on master: 049d078 added the index <span class=\"token function\">file</span>\nstash@<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span>: WIP on master: c264051 Revert <span class=\"token string\">\"added file_size\"</span>\nstash@<span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span>: WIP on master: 21d80a5 added number to log</code></pre></div>\n<p>Now let's apply our dirty changes back by popping them off the stack.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">git</span> stash pop\n<span class=\"token comment\"># On branch master</span>\n<span class=\"token comment\"># Changes not staged for commit:</span>\n<span class=\"token comment\">#   (use \"git add &lt;file>...\" to update what will be committed)</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\">#      modified:   index.html</span>\n<span class=\"token comment\">#      modified:   lib/simplegit.rb</span>\n<span class=\"token comment\">#</span></code></pre></div>\n<p><code class=\"language-text\">git stash apply</code> does the same thing</p>\n<p>Now you're ready to get back to work on your stuff!</p>\n<p><a href=\"http://git-scm.com/book/en/v1/Git-Tools-Stashing\">Additional Reading.</a></p>\n<h3>rebase (caution)</h3>\n<p>Take all changes that were committed on one branch, and replay them onto\nanother branch.\n<em>Do not rebase commits that you have pushed to a public repo</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Rebase experimentBranch onto master</span>\n<span class=\"token comment\"># git rebase &lt;basebranch> &lt;topicbranch></span>\n$ <span class=\"token function\">git</span> rebase master experimentBranch</code></pre></div>\n<p><a href=\"http://git-scm.com/book/en/Git-Branching-Rebasing\">Additional Reading.</a></p>\n<h3>reset (caution)</h3>\n<p>Reset the current HEAD to the specified state. This allows you to undo merges,\npulls, commits, adds, and more. It's a great command but also dangerous if you\ndon't know what you are doing.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Reset the staging area, to match the latest commit (leaves dir unchanged)</span>\n$ <span class=\"token function\">git</span> reset\n\n<span class=\"token comment\"># Reset the staging area, to match the latest commit, and overwrite working dir</span>\n$ <span class=\"token function\">git</span> reset --hard\n\n<span class=\"token comment\"># Moves the current branch tip to the specified commit (leaves dir unchanged)</span>\n<span class=\"token comment\"># all changes still exist in the directory.</span>\n$ <span class=\"token function\">git</span> reset 31f2bb1\n\n<span class=\"token comment\"># Moves the current branch tip backward to the specified commit</span>\n<span class=\"token comment\"># and makes the working dir match (deletes uncommitted changes and all commits</span>\n<span class=\"token comment\"># after the specified commit).</span>\n$ <span class=\"token function\">git</span> reset --hard 31f2bb1</code></pre></div>\n<h3>reflog (caution)</h3>\n<p>Reflog will list most of the git commands you have done for a given time period,\ndefault 90 days.</p>\n<p>This give you the chance to reverse any git commands that have gone wrong\n(for instance, if a rebase has broken your application).</p>\n<p>You can do this:</p>\n<ol>\n<li><code class=\"language-text\">git reflog</code> to list all of the git commands for the rebase</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">38b323f HEAD@{0}: rebase -i (finish): returning to refs/heads/feature/add_git_reflog\n38b323f HEAD@{1}: rebase -i (pick): Clarify inc/dec operators\n4fff859 HEAD@{2}: rebase -i (pick): Update java.html.markdown\n34ed963 HEAD@{3}: rebase -i (pick): [yaml/en] Add more resources (#1666)\ned8ddf2 HEAD@{4}: rebase -i (pick): pythonstatcomp spanish translation (#1748)\n2e6c386 HEAD@{5}: rebase -i (start): checkout 02fb96d</code></pre></div>\n<ol start=\"2\">\n<li>Select where to reset to, in our case its <code class=\"language-text\">2e6c386</code>, or <code class=\"language-text\">HEAD@{5}</code></li>\n<li>'git reset --hard HEAD@{5}' this will reset your repo to that head</li>\n<li>You can start the rebase again or leave it alone.</li>\n</ol>\n<p><a href=\"https://git-scm.com/docs/git-reflog\">Additional Reading.</a></p>\n<h3>revert</h3>\n<p>Revert can be used to undo a commit. It should not be confused with reset which\nrestores the state of a project to a previous point. Revert will add a new\ncommit which is the inverse of the specified commit, thus reverting it.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Revert a specified commit</span>\n$ <span class=\"token function\">git</span> revert <span class=\"token operator\">&lt;</span>commit<span class=\"token operator\">></span></code></pre></div>\n<h3>rm</h3>\n<p>The opposite of git add, git rm removes files from the current working tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># remove HelloWorld.c</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">rm</span> HelloWorld.c\n\n<span class=\"token comment\"># Remove a file from a nested dir</span>\n$ <span class=\"token function\">git</span> <span class=\"token function\">rm</span> /pather/to/the/file/HelloWorld.c</code></pre></div>\n<ul>\n<li><code class=\"language-text\">git checkout</code></li>\n<li><code class=\"language-text\">git reset</code></li>\n<li><code class=\"language-text\">git restore</code></li>\n<li><code class=\"language-text\">git switch</code></li>\n</ul>\n<p>I'll throw in one more, the misnamed <code class=\"language-text\">git revert</code>, as well.</p>\n<h3>From an end-user perspective</h3>\n<p>All you <em>need</em> are <code class=\"language-text\">git checkout</code>, <code class=\"language-text\">git reset</code>, and <code class=\"language-text\">git revert</code>. These commands have been in Git all along.</p>\n<p>But <code class=\"language-text\">git checkout</code> has, in effect, two <em>modes of operation</em>. One mode is \"safe\": it won't accidentally destroy any unsaved work. The other mode is \"unsafe\": if you use it, and it tells Git to wipe out some unsaved file, Git assumes that (a) you knew it meant that and (b) you really did mean to wipe out your unsaved file, so Git immediately wipes out your unsaved file.</p>\n<p>This is not very friendly, so the Git folks finally---after years of users griping---split <code class=\"language-text\">git checkout</code> into two new commands. This leads us to:</p>\n<h3>From a historical perspective</h3>\n<p><code class=\"language-text\">git restore</code> is <em>new</em>, having first come into existence in August 2019, in Git 2.23. <code class=\"language-text\">git reset</code> is very old, having been in Git all along, dating back to before 2005. Both commands have the ability to destroy unsaved work.</p>\n<p>The <code class=\"language-text\">git switch</code> command is also new, introduced along with <code class=\"language-text\">git restore</code> in Git 2.23. It implements the \"safe half\" of <code class=\"language-text\">git checkout</code>; <code class=\"language-text\">git restore</code> implements the \"unsafe half\".</p>\n<h3>When would you use which command?</h3>\n<p>This is the most complicated part, and to really understand it, we need to know the following items:</p>\n<ul>\n<li>Git is really all about <em>commits</em>. Commits get stored <em>in</em> the Git repository. The <code class=\"language-text\">git push</code> and <code class=\"language-text\">git fetch</code> commands transfer <em>commits</em>---whole commits, as an all-or-nothing deal^1^---to the other Git. You either have all of a commit, or you don't have it. Other commands, such as <code class=\"language-text\">git merge</code> or <code class=\"language-text\">git rebase</code>, all work with <em>local</em> commits. The <code class=\"language-text\">pull</code> command runs <code class=\"language-text\">fetch</code> (to get commits) followed by a second command to work with the commits once they're local.</li>\n<li>-</li>\n<li>New commits <em>add to the repository</em>. You almost never <em>remove</em> a commit <em>from</em> the repository. Only one of the five commands listed here---checkout, reset, restore, revert, and switch---is capable of removing commits.^2^</li>\n<li>-</li>\n<li>Each commit is numbered by its <em>hash ID</em>, which is unique to that one particular commit. It's actually computed from what's <em>in</em> the commit, which is how Git makes these numbers work across all Gits eveywhere. This means that what is in the commit is frozen for all time: if you change anything, what you get is a new commit with a new number, and the old commit is still there, with its same old number.</li>\n<li>Each commit stores two things: a snapshot, and metadata. The metadata include the hash ID(s) of some previous commit(s). This makes commits form backwards-looking chains.</li>\n<li>\n<p>A <em>branch name</em> holds the hash ID of one commit. This makes the branch name <em>find</em> that commit, which in turn means two things:</p>\n<ul>\n<li>that particular commit is the <em>tip commit</em> of that branch; and</li>\n<li>all commits leading up to and including that tip commit are <em>on</em> that branch.</li>\n</ul>\n</li>\n<li>We're also going to talk about Git's <em>index</em> in a moment, and your <em>working tree</em>. They're separate from these but worth mentioning early, especially since the index has three names: Git sometimes calls it the <em>index</em>, sometimes calls it the <em>staging area</em>, and sometimes---rarely these days---calls it the <em>cache</em>. All three names refer to the same thing.</li>\n</ul>\n<p>Everything up through the <em>branch name</em> is, I think, best understood via pictures (at least for most people). If we draw a series of commits, with newer commits towards the right, using <code class=\"language-text\">o</code> for each commit and omitting some commits for space or whatever, we get something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">        o--o---o   &lt;-- feature-top\n       /\\\no--o--o--o--...--o---o--o   &lt;-- main\n    \\               /\n     o--o--...--o--o   &lt;-- feature-hull</code></pre></div>\n<p>which, as you can see, is a boat repository. 😀 There are three branches. The mainline branch holds <em>every commit</em>, including all the commits on the top row and bottom (hull) row. The <code class=\"language-text\">feature-top</code> branch holds the top three commits and also the three commits along the main line to the left, but not any of the commits on the bottom row. All the connectors <em>between</em> commits are---well, <em>should be</em> but I don't have a good enough font---one-way arrows, pointing left, or down-and-left, or up-and-left.</p>\n<p>These \"arrows\", or one way connections from commit to commit, are technically <a href=\"https://math.stackexchange.com/a/31208\"><em>arcs</em>, or one-way edges</a>, in a <a href=\"https://en.wikipedia.org/wiki/Directed_graph\"><em>directed graph</em></a>. This directed graph is one without cycles, making it a Directed Acyclic Graph or <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">DAG</a>, which has a bunch of properties that are useful to Git.</p>\n<p>If you're just using Git to store files inside commits, all you really care about are the round <code class=\"language-text\">o</code> <a href=\"https://math.stackexchange.com/a/1441525\"><em>nodes</em> or <em>vertices</em> (again two words for the same thing)</a>, each of which acts to store your files, but you should at least be vaguely aware of how they are arranged. It matters, especially because of <em>merges</em>. Merge commits are those with two outgoing arcs, pointing backwards to two of what Git calls <em>parent commits</em>. The child commit is the one \"later\": just as human parents are always older than their children, Git parent commits are older than their children.</p>\n<p>We need one more thing, though: <strong>Where do new commits come from?</strong> We noted that what's in a commit---both the snapshot, holding all the files, and the metadata, holding the rest of the information Git keeps about a commit---is all read-only. Your files are not only frozen, they're also <em>transformed</em>, and the transformed data are then <em>de-duplicated</em>, so that even though every commit has a full snapshot of <em>every</em> file, the repository itself stays relatively slim. But this means that the files <em>in</em> a commit can only be <em>read</em> by Git, and <em>nothing</em>---not even Git itself---can <em>write</em> to them. They get saved once, and are de-duplicated from then on. The commits act as archives, almost like tar or rar or winzip or whatever.</p>\n<p>To work with a Git repository, then, we have to have Git <em>extract</em> the files. This takes the files <em>out</em> of some commit, turning those special archive-formatted things into regular, usable files. Note that Git may well be able to store files that your computer literally <em>can't</em> store: a classic example is a file named <code class=\"language-text\">aux.h</code>, for some C program, on a Windows machine. We won't go into all the details, but it is theoretically possible to still get work done with this repository, which was probably built on a Linux system, even if you're on a Windows system where you can't work with the <code class=\"language-text\">aux.h</code> file directly.</p>\n<p>Anyway, assuming there are no nasty little surprises like <code class=\"language-text\">aux.h</code>, you would just run <code class=\"language-text\">git checkout</code> or <code class=\"language-text\">git switch</code> to get some commit <em>out</em> of Git. This will fill in your <em>working tree</em>, populating it from the files stored in the <em>tip commit</em> of some branch. The <em>tip commit</em> is, again, the <em>last</em> commit on that branch, as found by the <em>branch name</em>. Your <code class=\"language-text\">git checkout</code> or <code class=\"language-text\">git switch</code> selected that commit to be the <em>current commit</em>, by selecting that branch name to be the <em>current branch</em>. You now have all the files <em>from</em> that commit, in an area where you can see them and work on them: your <em>working tree</em>.</p>\n<p>Note that the files in your working tree <em>are not actually in Git itself</em>. They were just <em>extracted from</em> Git. This matters a lot, because when <code class=\"language-text\">git checkout</code> extracts the files <em>from</em> Git, it actually puts each file in two places. One of those places is the ordinary everyday file you see and work on / with. The other place Git puts each file is into Git's <em>index</em>.</p>\n<p>As I mentioned a moment ago, the index has three names: index, staging area, and cache. All refer to the same thing: the place Git sticks these \"copies\" of each file. Each one is actually pre-de-duplicated, so the word \"copy\" is slightly wrong, but---unlike much of the rest of its innards---Git actually does a really good job of hiding the de-duplication aspect. Unless you start getting into internal commands like <code class=\"language-text\">git ls-files</code> and <code class=\"language-text\">git update-index</code>, you don't need to know about this part, and can just think of the index as holding a copy of the file, ready to go into the <em>next commit</em>.</p>\n<p>What this all means for you as someone just <em>using</em> Git is that the index / staging-area acts as your <em>proposed next commit</em>. When you run <code class=\"language-text\">git commit</code>, Git is going to package up <em>these</em> copies of the file as the ones to be archived in the snapshot. The copies you have in your working tree are <em>yours;</em> the <em>index / staging-area</em> copies are <em>Git's</em>, ready to go. So, if you <em>change</em> your copies and want the <em>changed</em> copy to be what goes in the next snapshot, you must tell Git: <em>Update the Git copy, in the Git index / staging-area.</em> You do this with <code class=\"language-text\">git add</code>.^3^ The <code class=\"language-text\">git add</code> command means <em>make the proposed-next-commit copy match the working-tree copy</em>. It's the <code class=\"language-text\">add</code> command that does the updating: this is when Git compresses and de-duplicates the file and makes it ready for archiving, not at <code class=\"language-text\">git commit</code> time.^4^</p>\n<p>Then, assuming you have some series of commits ending with the one with <em><code class=\"language-text\">hash-N</code>:</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[hash1] &lt;-[hash2] ... &lt;-[hashN]   &lt;--branch</code></pre></div>\n<p>you run <code class=\"language-text\">git commit</code>, give it any metadata it needs (a commit log message), and you get an N+1'th commit:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[hash1] &lt;-[hash2] ... &lt;-[hashN] &lt;-[hashN+1]   &lt;--branch</code></pre></div>\n<p>Git automatically updates the <em>branch name</em> to point to the <em>new commit</em>, which has therefore been <em>added to the branch</em>.</p>\n<p>Let's look at each of the various commands now:</p>\n<ul>\n<li>\n<p><code class=\"language-text\">git checkout</code>: this is a large and complicated command.</p>\n<p>We already saw this one, or at least, <em>half</em> of this one. We used it to pick out a branch name, and therefore a particular commit. This kind of checkout first looks at our current commit, index, and working tree. It makes sure that we have committed all our modified files, or---this part gets a bit complicated---that if we <em>haven't</em> committed all our modified files, switching to that other branch is \"safe\". If it's <em>not</em> safe, <code class=\"language-text\">git checkout</code> tells you that you can't switch due to having modified files. If it <em>is</em> safe, <code class=\"language-text\">git checkout</code> will switch; if you didn't mean to switch, you can just switch back. (See also <a href=\"https://stackoverflow.com/q/22053757/1256452\">Checkout another branch when there are uncommitted changes on the current branch</a>)</p>\n<p>But <code class=\"language-text\">git checkout</code> has an <em>unsafe</em> half. Suppose you have modified some file in your working tree, such as <code class=\"language-text\">README.md</code> or <code class=\"language-text\">aux.h</code> or whatever. You now look back at what you changed and think: <em>No, that's a bad idea. I should get rid of this change. I'd like the file back exactly as it was before.</em></p>\n<p>To get this---to <em>wipe out</em> your changes to, say, <code class=\"language-text\">README.md</code>---you can run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout -- README.md</code></pre></div>\n<p>The <code class=\"language-text\">--</code> part here is optional. It's a good idea to use it, because it tells Git that the part that comes after <code class=\"language-text\">--</code> is a <em>file name</em>, not a <em>branch name</em>.</p>\n<p>Suppose you have a <em>branch</em> named <code class=\"language-text\">hello</code> <em>and</em> a <em>file</em> named <code class=\"language-text\">hello</code>. What does:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout hello</code></pre></div>\n<p>mean? Are we asking Git to clobber the <em>file</em> <code class=\"language-text\">hello</code> to remove the changes we made, or are we asking Git to check out the <em>branch</em> <code class=\"language-text\">hello</code>? To make this unambiguous, you have to write either:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout -- hello        (clobber the file)</code></pre></div>\n<p>or:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">git checkout hello --      (get the branch)</code></pre></div>\n<p>This case, where there are branches and files or directories with the same name, is a particularly insidious one. It has bitten real users. It's <em>why</em> <code class=\"language-text\">git switch</code> exists now. The <code class=\"language-text\">git switch</code> command <em>never means clobber my files</em>. It only means <em>do the safe kind of <code class=\"language-text\">git checkout</code>.</em></p>\n<p>(The <code class=\"language-text\">git checkout</code> command has been smartened up too, so that if you have the new commands and you run the \"bad\" kind of ambiguous <code class=\"language-text\">git checkout</code>, Git will just complain at you and do nothing at all. Either use the smarter split-up commands, or add the <code class=\"language-text\">--</code> at the right place to pick which kind of operation you want.)</p>\n<p>More precisely, <em>this kind</em> of <code class=\"language-text\">git checkout</code>, ideally spelled <code class=\"language-text\">git checkout -- *paths*</code>, is a request for Git to copy files from Git's index to your working tree. This means <em>clobber my files</em>. You can also run <code class=\"language-text\">git checkout *tree-ish* -- *paths*</code>, where you add a commit hash ID^5^ to the command. This tells Git to copy the files from that commit, first to Git's index, and then on to your working tree. This, too, means <em>clobber my files:</em> the difference is where Git gets the copies of the files it's extracting.</p>\n<p>If you ran <code class=\"language-text\">git add</code> on some file and thus copied it into Git's index, you need <code class=\"language-text\">git checkout HEAD -- *file*</code> to get it back from the current commit. The copy that's in Git's <em>index</em> is the one you <code class=\"language-text\">git add</code>-ed. So these two forms of <code class=\"language-text\">git checkout</code>, with a commit hash ID (or the name <code class=\"language-text\">HEAD</code>), the optional <code class=\"language-text\">--</code>, and the file name, are the unsafe <em>clobber my files</em> forms.</p>\n</li>\n<li>\n<p><code class=\"language-text\">git reset</code>: this is also a large and complicated command.</p>\n<p>There are, depending on how you count, up to about five or six different forms of <code class=\"language-text\">git reset</code>. We'll concentrate on a smaller subset here.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">git reset [ --hard | --mixed | --soft ] [ *commit* ]</code></p>\n<p>Here, we're asking Git to do several things. First, if we give a <em><code class=\"language-text\">commit</code></em> argument, such as <code class=\"language-text\">HEAD</code> or <code class=\"language-text\">HEAD~3</code> or some such, we've picked a particular <em>commit</em> that Git should <em>reset to</em>. This is the kind of command that will <em>remove commits</em> by ejecting them off the end of the branch. Of all the commands listed here, this is the only one that removes any commits. One other command---<code class=\"language-text\">git commit --amend</code>---has the effect of ejecting the <em>last</em> commit while putting on a new replacement, but that one is limited to ejecting <em>one</em> commit.</p>\n<p>Let's show this as a drawing. Suppose we have:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...--E--F--G--H   &lt;-- branch</code></pre></div>\n<p>That is, this branch, named <code class=\"language-text\">branch</code>, ends with four commits whose hash IDs we'll call <code class=\"language-text\">E</code>, <code class=\"language-text\">F</code>, <code class=\"language-text\">G</code>, and <code class=\"language-text\">H</code> in that order. The name <code class=\"language-text\">branch</code> currently stores the hash ID of the last of these commits, <code class=\"language-text\">H</code>. If we use <code class=\"language-text\">git reset --hard HEAD~3</code>, we're telling Git to eject the <em>last three commits</em>. The result is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">       F--G--H   ???\n      /\n...--E   &lt;-- branch</code></pre></div>\n<p>The name <code class=\"language-text\">branch</code> now selects commit <code class=\"language-text\">E</code>, not commit <code class=\"language-text\">H</code>. If we did not write down (on paper, on a whiteboard, in a file) the hash IDs of the last three commits, they've just become somewhat hard to find. Git does gives a way to find them again, for a while, but mostly they just seem to be <em>gone</em>.</p>\n<p>The <code class=\"language-text\">HEAD~3</code> part of this command is how we chose to drop the last three commits. It's part of a whole sub-topic in Git, documented in <a href=\"https://git-scm.com/docs/gitrevisions\">the gitrevisions manual</a>, on ways to name specific commits. The reset command just needs the hash ID of an actual commit, or anything equivalent, and <code class=\"language-text\">HEAD~3</code> means <em>go back three first-parent steps</em>, which in this case gets us from commit <code class=\"language-text\">H</code> back to commit <code class=\"language-text\">E</code>.</p>\n<p>The <code class=\"language-text\">--hard</code> part of the <code class=\"language-text\">git reset</code> is how we tell Git what to do with (a) its index and (b) our working tree files. We have three choices here:</p>\n<ul>\n<li><code class=\"language-text\">--soft</code> tells Git: <em>leave both alone</em>. Git will move the <em>branch name</em> without touching the index or our working tree. If you run <code class=\"language-text\">git commit</code> now, whatever is (still) in the index is what goes into the <em>new</em> commit. If the index matches the snapshot in commit <code class=\"language-text\">H</code>, this gets you a new commit whose <em>snapshot</em> is <code class=\"language-text\">H</code>, but whose <em>parent</em> is <code class=\"language-text\">E</code>, as if commits <code class=\"language-text\">F</code> through <code class=\"language-text\">H</code> had all been collapsed into a single new commit. People usually call this <em>squashing</em>.</li>\n<li><code class=\"language-text\">--mixed</code> tells Git: <em>reset your index, but leave my working tree alone</em>. Git will move the branch name, then <em>replace every file that is in the index with the one from the newly selected commit</em>. But Git will leave all your <em>working tree</em> files alone. This means that as far as Git is concerned, you can start <code class=\"language-text\">git add</code>ing files to make a new commit. Your new commit won't match <code class=\"language-text\">H</code> unless you <code class=\"language-text\">git add</code> <em>everything</em>, so this means you could, for instance, build a new intermediate commit, sort of like <code class=\"language-text\">E+F</code> or something, if you wanted.</li>\n<li><code class=\"language-text\">--hard</code> tells Git: <em>reset your index <strong>and</strong> my working tree.</em> Git will move the branch name, replace all the files in its index, and replace all the files in your working tree, all as one big thing. It's now as if you never made those three commits at all. You no longer have the files from <code class=\"language-text\">F</code>, or <code class=\"language-text\">G</code>, or <code class=\"language-text\">H</code>: you have the files from commit <code class=\"language-text\">E</code>.</li>\n</ul>\n<p>Note that if you leave out the <em><code class=\"language-text\">commit</code></em> part of this kind of (hard/soft/mixed) <code class=\"language-text\">reset</code>, Git will use <code class=\"language-text\">HEAD</code>. Since <code class=\"language-text\">HEAD</code> names the <em>current commit</em> (as selected by the current branch name), this leaves the branch name itself unchanged: it still selects the same commit as before. So this is only useful with <code class=\"language-text\">--mixed</code> or <code class=\"language-text\">--hard</code>, because <code class=\"language-text\">git reset --soft</code>, with no commit hash ID, means <em>don't move the branch name, don't change Git's index, and don't touch my working tree</em>. Those are the three things this kind of <code class=\"language-text\">git reset</code> can do---move the branch name, change what's in Git's index, and change what's in your working tree---and you just ruled all three out. Git is OK with doing nothing, but why bother?</p>\n</li>\n<li>\n<p><code class=\"language-text\">git reset [ *tree-ish* ] -- *path*</code></p>\n<p>This is the other kind of <code class=\"language-text\">git reset</code> we'll care about here. It's a bit like a mixed reset, in that it means <em>clobber some of the index copies of files</em>, but here you specify <em>which files to clobber</em>. It's also a bit <em>unlike</em> a mixed reset, because this kind of <code class=\"language-text\">git reset</code> will never move the branch name.</p>\n<p>Instead, you pick which files you want copied from somewhere. The <em>somewhere</em> is the <em><code class=\"language-text\">tree-ish</code></em> you give; if you don't give one, the <em>somewhere</em> is <code class=\"language-text\">HEAD</code>, i.e., the current commit. This can only restore files in the <em>proposed next commit</em> to the form they have in <em>some existing commit</em>. By defaulting to the <em>current</em> existing commit, this kind of <code class=\"language-text\">git reset -- *path*</code> has the effect of undoing a <code class=\"language-text\">git add -- *path*</code>.^6^</p>\n<p>There are several other forms of <code class=\"language-text\">git reset</code>. To see what they all mean, consult <a href=\"https://git-scm.com/docs/git-reset\">the documentation</a>.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">git restore</code>: this got split off from <code class=\"language-text\">git checkout</code>.</p>\n<p>Basically, this does the same thing as the various forms of <code class=\"language-text\">git checkout</code> and <code class=\"language-text\">git reset</code> that clobber files (in your working tree and/or in Git's index). It's <em>smarter</em> than the old <code class=\"language-text\">git checkout</code>-and-clobber-my-work variant, in that you get to choose where the files come from <em>and</em> where they go, all in the one command line.</p>\n<p>To do what you used to do with <code class=\"language-text\">git checkout -- *file*</code>, you just run <code class=\"language-text\">git restore --staged --worktree -- *file*</code>. (You can leave out the <code class=\"language-text\">--</code> part, as with <code class=\"language-text\">git checkout</code>, in most cases, but it's just generally wise to get in the habit of using it. Like <code class=\"language-text\">git add</code>, this command is designed such that only files named <code class=\"language-text\">-whatever</code> are actually problematic.)</p>\n<p>To do what you used to do with <code class=\"language-text\">git reset -- *file*</code>, you just run <code class=\"language-text\">git restore --staged -- *file*</code>. That is, you tell <code class=\"language-text\">git restore</code> to copy from <code class=\"language-text\">HEAD</code> to staging area / index, which is how <code class=\"language-text\">git reset</code> operates.</p>\n<p>Note that you can copy a file from some existing commit, to Git's index, without touching your working tree copy of that file: <code class=\"language-text\">git restore --source *commit* --staged -- *file*</code> does that. You can't do that at all with the old <code class=\"language-text\">git checkout</code> but you <em>can</em> do that with the old <code class=\"language-text\">git reset</code>, as <code class=\"language-text\">git reset *commit* -- *file*</code>. And, you can copy a file from some existing commit, to your working tree, without touching the staged copy: <code class=\"language-text\">git restore --source *commit* --worktree -- *file*</code> does that. The overlapping part (restore and reset) exists <em>because</em> <code class=\"language-text\">git restore</code> is new, and this kind of restore makes sense; probably, ideally, we should always use <code class=\"language-text\">git restore</code> here, instead of using the old <code class=\"language-text\">git reset</code> way of doing things, but Git tries to maintain backwards compatibility.</p>\n<p>The new ability---to copy from any arbitrary source, to your working tree, without touching Git's index / staging-area copy---is just that: new. You couldn't do it before. (You could run <code class=\"language-text\">git show *commit*:*path* > *path*</code>, before, but that falls outside our five commands to examine.)</p>\n</li>\n<li><code class=\"language-text\">git switch</code>: this just does the \"safe half\" of <code class=\"language-text\">git checkout</code>. That's really all you need to know. Using <code class=\"language-text\">git switch</code>, without <code class=\"language-text\">--force</code>, Git won't overwrite your unsaved work, even if you make a typo or whatever. The old <code class=\"language-text\">git checkout</code> command could overwrite unsaved work: if your typo turns a branch name into a file name, for instance, well, oops.</li>\n<li>-</li>\n<li>\n<p><code class=\"language-text\">git revert</code> (I added this for completeness): this makes a <em>new commit</em>. The point of the new commit is to <em>back out</em> what someone did in some existing commit. You therefore need to name the existing commit that revert should back out. This command probably should have been named <code class=\"language-text\">git backout</code>.</p>\n<p>If you back out the most recent commit, this does revert to the second-most-recent snapshot:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ...--G--H   &lt;-- branch</code></pre></div>\n<p>becomes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ...--G--H--Ħ   &lt;-- branch</code></pre></div>\n<p>where commit <code class=\"language-text\">Ħ</code> (H-bar) \"undoes\" commit <code class=\"language-text\">H</code> and therefore leaves us with the same <em>files</em> as commit <code class=\"language-text\">G</code>. But we don't have to undo the <em>most recent</em> commit. We could take:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ...--E--F--G--H   &lt;-- branch</code></pre></div>\n<p>and add a commit <code class=\"language-text\">Ǝ</code> that undoes <code class=\"language-text\">E</code> to get:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  ...--E--F--G--H--Ǝ   &lt;-- branch</code></pre></div>\n<p>which may not match the source snapshot of any previous commit!</p>\n</li>\n</ul>\n<h2>Further Information</h2>\n<ul>\n<li><a href=\"http://try.github.io/levels/1/challenges/1\">tryGit - A fun interactive way to learn Git.</a></li>\n<li>-</li>\n<li>[Learn Git Branching - the most visual and interactive way to learn Git on the web](<a href=\"http://learngitbranch\">http://learngitbranch</a></li>\n<li>-</li>\n<li>[Udemy Git Tutorial: A Comprehensive Guide](<a href=\"https://blog\">https://blog</a></li>\n<li>-</li>\n<li>[Git Immersion - A Guided tour that walks through the fundamentals of git</li>\n<li>-</li>\n<li>[git-scm - Video Tutorials](<a href=\"http://g\">http://g</a></li>\n<li>-</li>\n<li>[git-scm - Documentation](<a href=\"http://git-scm.com/d\">http://git-scm.com/d</a></li>\n<li>-</li>\n<li><a href=\"https://www.atlassian.com/git/\">Atlassian Git - Tutorials &#x26; Workflows</a></li>\n<li><a href=\"http://res.cloudinary.com/hy4kyit2a/image/upload/SF_git_cheatsheet.pdf\">SalesForce Cheat Sheet</a></li>\n<li><a href=\"http://www.gitguys.com/\">GitGuys</a></li>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.html\">Git - the simple guide</a></li>\n<li><a href=\"http://www.git-scm.com/book/en/v2\">Pro Git</a></li>\n<li><a href=\"http://product.hubspot.com/blog/git-and-github-tutorial-for-beginners\">An introduction to Git and GitHub for Beginners (Tutorial)</a></li>\n<li><a href=\"https://www.youtube.com/playlist?list=PL6gx4Cwl9DGAKWClAD_iKpNC0bGHxGhcx\">The New Boston tutorial to Git covering basic commands and workflow</a></li>\n</ul>"}