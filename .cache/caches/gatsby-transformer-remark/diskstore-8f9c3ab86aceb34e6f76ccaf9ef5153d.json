{"expireTime":9007200911870455000,"key":"transformer-remark-markdown-html-483a662392c28f131e947f1b585b7a7b-gatsby-remark-prismjs-","val":"<h1>eval()</h1>\n<p><strong>Warning:</strong> Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use <code class=\"language-text\">eval()</code>. See <a href=\"#never_use_eval!\">Never use eval()!</a>, below.</p>\n<p>The <code class=\"language-text\">eval()</code> function evaluates JavaScript code represented as a string.</p>\n<h2>Syntax</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eval(string)</code></pre></div>\n<h3>Parameters</h3>\n<p><code class=\"language-text\">string</code>\nA string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects.</p>\n<h3>Return value</h3>\n<p>The completion value of evaluating the given code. If the completion value is empty, <a href=\"undefined\"><code class=\"language-text\">undefined</code></a> is returned.</p>\n<h2>Description</h2>\n<p><code class=\"language-text\">eval()</code> is a function property of the global object.</p>\n<p>The argument of the <code class=\"language-text\">eval()</code> function is a string. If the string represents an expression, <code class=\"language-text\">eval()</code> evaluates the expression. If the argument represents one or more JavaScript statements, <code class=\"language-text\">eval()</code> evaluates the statements. Do not call <code class=\"language-text\">eval()</code> to evaluate an arithmetic expression; JavaScript evaluates arithmetic expressions automatically.</p>\n<p>If you construct an arithmetic expression as a string, you can use <code class=\"language-text\">eval()</code> to evaluate it at a later time. For example, suppose you have a variable <code class=\"language-text\">x</code>. You can postpone evaluation of an expression involving <code class=\"language-text\">x</code> by assigning the string value of the expression, say \"<code class=\"language-text\">3 * x + 2</code>\", to a variable, and then calling <code class=\"language-text\">eval()</code> at a later point in your script.</p>\n<p>If the argument of <code class=\"language-text\">eval()</code> is not a string, <code class=\"language-text\">eval()</code> returns the argument unchanged. In the following example, the <code class=\"language-text\">String</code> constructor is specified and <code class=\"language-text\">eval()</code> returns a <code class=\"language-text\">String</code> object rather than evaluating the string.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eval(new String('2 + 2')); // returns a String object containing \"2 + 2\"\neval('2 + 2');             // returns 4</code></pre></div>\n<p>You can work around this limitation in a generic fashion by using <code class=\"language-text\">toString()</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var expression = new String('2 + 2');\neval(expression.toString());            // returns 4</code></pre></div>\n<p>If you use the <code class=\"language-text\">eval</code> function <em>indirectly,</em> by invoking it via a reference other than <code class=\"language-text\">eval</code>, <a href=\"https://www.ecma-international.org/ecma-262/5.1/#sec-10.4.2\">as of ECMAScript 5</a> it works in the global scope rather than the local scope. This means, for instance, that function declarations create global functions, and that the code being evaluated doesn't have access to local variables within the scope where it's being called.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function test() {\n  var x = 2, y = 4;\n  // Direct call, uses local scope\n  console.log(eval('x + y')); // Result is 6\n  // Indirect call using the comma operator to return eval\n  console.log((0, eval)('x + y')); // Uses global scope, throws because x is undefined\n  // Indirect call using a variable to store and return eval\n  var geval = eval;\n  console.log(geval('x + y')); // Uses global scope, throws because x is undefined\n}</code></pre></div>\n<h2>Never use eval()!</h2>\n<p><code class=\"language-text\">eval()</code> is a dangerous function, which executes the code it's passed with the privileges of the caller. If you run <code class=\"language-text\">eval()</code> with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, a third-party code can see the scope in which <code class=\"language-text\">eval()</code> was invoked, which can lead to possible attacks in ways to which the similar <a href=\"function\"><code class=\"language-text\">Function</code></a> is not susceptible.</p>\n<p><code class=\"language-text\">eval()</code> is also slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.</p>\n<p>Additionally, modern javascript interpreters convert javascript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of <code class=\"language-text\">eval()</code> will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through <code class=\"language-text\">eval()</code> such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.</p>\n<p>Fortunately, there's a very good alternative to <code class=\"language-text\">eval()</code>: using <a href=\"function\"><code class=\"language-text\">window.Function()</code></a>. See this example of how to convert code using a dangerous <code class=\"language-text\">eval()</code> to using <code class=\"language-text\">Function()</code>, see below.</p>\n<p>Bad code with <code class=\"language-text\">eval()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function looseJsonParse(obj){\n    return eval(\"(\" + obj + \")\");\n}\nconsole.log(looseJsonParse(\n   \"{a:(4-1), b:function(){}, c:new Date()}\"\n))</code></pre></div>\n<p>Better code without <code class=\"language-text\">eval()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function looseJsonParse(obj){\n    return Function('\"use strict\";return (' + obj + ')')();\n}\nconsole.log(looseJsonParse(\n   \"{a:(4-1), b:function(){}, c:new Date()}\"\n))</code></pre></div>\n<p>Comparing the two code snippets above, the two code snippets might seem to work the same way, but think again: the <code class=\"language-text\">eval()</code> one is a great deal slower. Notice <code class=\"language-text\">c: new Date()</code> in the evaluated object. In the function without the <code class=\"language-text\">eval()</code>, the object is being evaluated in the global scope, so it is safe for the browser to assume that <code class=\"language-text\">Date</code> refers to <code class=\"language-text\">window.Date()</code> instead of a local variable called <code class=\"language-text\">Date</code>. But, in the code using <code class=\"language-text\">eval()</code>, the browser cannot assume this since what if your code looked like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Date(n){\n    return [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"][n%7 || 0];\n}\nfunction looseJsonParse(obj){\n    return eval(\"(\" + obj + \")\");\n}\nconsole.log(looseJsonParse(\n   \"{a:(4-1), b:function(){}, c:new Date()}\"\n))</code></pre></div>\n<p>Thus, in the <code class=\"language-text\">eval()</code> version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called <code class=\"language-text\">Date()</code>. This is incredibly inefficient compared to <code class=\"language-text\">Function()</code>.</p>\n<p>In a related circumstance, what if you actually wanted your <code class=\"language-text\">Date()</code> function to be able to be called from the code inside <code class=\"language-text\">Function()</code>. Should you just take the easy way out and fall back to <code class=\"language-text\">eval()</code>? No! Never. Instead try the approach below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Date(n){\n    return [\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\"][n%7 || 0];\n}\nfunction runCodeWithDateFunction(obj){\n    return Function('\"use strict\";return (' + obj + ')')()(\n        Date\n    );\n}\nconsole.log(runCodeWithDateFunction(\n   \"function(Date){ return Date(5) }\"\n))</code></pre></div>\n<p>The code above may seem inefficiently slow because of the triple nested function, but let's analyze the benefits of the above efficient method:</p>\n<ul>\n<li>It allows the code in the string passed to <code class=\"language-text\">runCodeWithDateFunction()</code> to be minified.</li>\n<li>Function call overhead is minimal, making the far smaller code size well worth the benefit</li>\n<li><code class=\"language-text\">Function()</code> more easily allows your code to utilize the performance buttering <code class=\"language-text\">\"use strict\";</code></li>\n<li>The code does not use <code class=\"language-text\">eval()</code>, making it orders of magnitude faster than otherwise.</li>\n</ul>\n<p>Lastly, let's examine minification. With using <code class=\"language-text\">Function()</code> as shown above, you can minify the code string passed to <code class=\"language-text\">runCodeWithDateFunction()</code> far more efficiently because the function arguments names can be minified too as seen in the minified code below.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(Function('\"use strict\";return(function(a){return a(5)})')()(function(a){\nreturn\"Monday Tuesday Wednesday Thursday Friday Saturday Sunday\".split(\" \")[a%7||0]}));</code></pre></div>\n<p>There are also additional safer (and faster!) alternatives to <code class=\"language-text\">eval()</code> or <code class=\"language-text\">Function()</code> for common use-cases.</p>\n<h3>Accessing member properties</h3>\n<p>You should not use <code class=\"language-text\">eval()</code> to convert property names into properties. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with <code class=\"language-text\">eval()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = { a: 20, b: 30 };\nvar propName = getPropName();  // returns \"a\" or \"b\"\n\neval( 'var result = obj.' + propName );</code></pre></div>\n<p>However, <code class=\"language-text\">eval()</code> is not necessary here. In fact, its use here is discouraged. Instead, use the <a href=\"../operators/property_accessors\">property accessors</a>, which are much faster and safer:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = { a: 20, b: 30 };\nvar propName = getPropName();  // returns \"a\" or \"b\"\nvar result = obj[ propName ];  //  obj[ \"a\" ] is the same as obj.a</code></pre></div>\n<p>You can even use this method to access descendant properties. Using <code class=\"language-text\">eval()</code> this would look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var obj = {a: {b: {c: 0}}};\nvar propPath = getPropPath();  // returns e.g. \"a.b.c\"\n\neval( 'var result = obj.' + propPath );</code></pre></div>\n<p>Avoiding <code class=\"language-text\">eval()</code> here could be done by splitting the property path and looping through the different properties:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getDescendantProp(obj, desc) {\n  var arr = desc.split('.');\n  while (arr.length) {\n    obj = obj[arr.shift()];\n  }\n  return obj;\n}\n\nvar obj = {a: {b: {c: 0}}};\nvar propPath = getPropPath();  // returns e.g. \"a.b.c\"\nvar result = getDescendantProp(obj, propPath);</code></pre></div>\n<p>Setting a property that way works similarly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function setDescendantProp(obj, desc, value) {\n  var arr = desc.split('.');\n  while (arr.length > 1) {\n    obj = obj[arr.shift()];\n  }\n  return obj[arr[0]] = value;\n}\n\nvar obj = {a: {b: {c: 0}}};\nvar propPath = getPropPath();  // returns e.g. \"a.b.c\"\nvar result = setDescendantProp(obj, propPath, 1);  // obj.a.b.c will now be 1</code></pre></div>\n<h3>Use functions instead of evaluating snippets of code</h3>\n<p>JavaScript has <a href=\"https://en.wikipedia.org/wiki/First-class_function\">first-class functions</a>, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// instead of setTimeout(\" ... \", 1000) use:\nsetTimeout(function() { ... }, 1000);\n\n// instead of elt.setAttribute(\"onclick\", \"...\") use:\nelt.addEventListener('click', function() { ... } , false);</code></pre></div>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\">Closures</a> are also helpful as a way to create parameterized functions without concatenating strings.</p>\n<h3>Parsing JSON (converting strings to JavaScript objects)</h3>\n<p>If the string you're calling <code class=\"language-text\">eval()</code> on contains data (for example, an array: <code class=\"language-text\">\"[1, 2, 3]\"</code>), as opposed to code, you should consider switching to <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/JSON\">JSON</a>, which allows the string to use a subset of JavaScript syntax to represent data.</p>\n<p>Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.</p>\n<h3>Pass data instead of code</h3>\n<p>For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in <a href=\"https://developer.mozilla.org/en-US/docs/Web/XPath\">XPath</a> instead of JavaScript code.</p>\n<h2>Examples</h2>\n<h3>Using <code class=\"language-text\">eval</code></h3>\n<p>In the following code, both of the statements containing <code class=\"language-text\">eval()</code> return 42. The first evaluates the string \"<code class=\"language-text\">x + y + 1</code>\"; the second evaluates the string \"<code class=\"language-text\">42</code>\".</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 2;\nvar y = 39;\nvar z = '42';\neval('x + y + 1'); // returns 42\neval(z);           // returns 42</code></pre></div>\n<h3>Using <code class=\"language-text\">eval</code> to evaluate a string of JavaScript statements</h3>\n<p>The following example uses <code class=\"language-text\">eval()</code> to evaluate the string <code class=\"language-text\">str</code>. This string consists of JavaScript statements that assigns <code class=\"language-text\">z</code> a value of 42 if <code class=\"language-text\">x</code> is five, and assigns 0 to <code class=\"language-text\">z</code> otherwise. When the second statement is executed, <code class=\"language-text\">eval()</code> will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to <code class=\"language-text\">z</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 5;\nvar str = \"if (x == 5) {console.log('z is 42'); z = 42;} else z = 0;\";\n\nconsole.log('z is ', eval(str));</code></pre></div>\n<p>If you define multiple values then the last value is returned.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var x = 5;\nvar str = \"if (x == 5) {console.log('z is 42'); z = 42; x = 420; } else z = 0;\";\n\nconsole.log('x is ', eval(str)); // z is 42  x is 420</code></pre></div>\n<h3>Last expression is evaluated</h3>\n<p><code class=\"language-text\">eval()</code> returns the value of the last expression evaluated.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var str = 'if ( a ) { 1 + 1; } else { 1 + 2; }';\nvar a = true;\nvar b = eval(str);  // returns 2\n\nconsole.log('b is : ' + b);\n\na = false;\nb = eval(str);  // returns 3\n\nconsole.log('b is : ' + b);</code></pre></div>\n<h3><code class=\"language-text\">eval</code> as a string defining function requires \"(\" and \")\" as prefix and suffix</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var fctStr1 = 'function a() {}'\nvar fctStr2 = '(function a() {})'\nvar fct1 = eval(fctStr1)  // return undefined\nvar fct2 = eval(fctStr2)  // return a function</code></pre></div>"}