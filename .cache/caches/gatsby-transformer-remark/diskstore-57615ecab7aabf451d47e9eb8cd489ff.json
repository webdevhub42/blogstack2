{"expireTime":9007200911206588000,"key":"transformer-remark-markdown-html-7bbbf64388ce0716ba15c83892949444-gatsby-remark-prismjs-","val":"<h2>Main Concepts</h2>\n<p>This document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our <a href=\"https://reactrouter.com/docs/en/v6/getting-started/tutorial\">quick start tutorial</a>.</p>\n<p>You might be wondering what exactly React Router does. How can it help you build your app? What exactly is a <strong>router</strong>, anyway?</p>\n<p>If you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.</p>\n<p>Please don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it.</p>\n<p>React Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:</p>\n<ol>\n<li>Subscribing and manipulating the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a></li>\n<li>Matching the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> to your <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">routes</a></li>\n<li>Rendering a nested UI from the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#matches\">route matches</a></li>\n</ol>\n<h2>Definitions</h2>\n<p>But first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.</p>\n<p>Here are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.</p>\n<ul>\n<li><strong>URL</strong> - The URL in the address bar. A lot of people use the term \"URL\" and \"route\" interchangeably, but this is not a route in React Router, it's just a URL.</li>\n<li><strong>Location</strong> - This is a React Router specific object that is based on the built-in browser's <code class=\"language-text\">window.location</code> object. It represents \"where the user is at\". It's mostly an object representation of the URL but has a bit more to it than that.</li>\n<li><strong>Location State</strong> - A value that persists with a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> that isn't encoded in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>. Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.</li>\n<li><strong>History Stack</strong> - As the user navigates, the browser keeps track of each <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.</li>\n<li><strong>Client Side Routing (CSR)</strong> - A plain HTML document can link to other documents and the browser handles the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a> itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.</li>\n<li><strong>History</strong> - An object that allows React Router to subscribe to changes in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> as well as providing APIs to manipulate the browser <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a> programmatically.</li>\n<li><strong>History Action</strong> - One of <code class=\"language-text\">POP</code>, <code class=\"language-text\">PUSH</code>, or <code class=\"language-text\">REPLACE</code>. Users can arrive at a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.</li>\n<li><strong>Segment</strong> - The parts of a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> or <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#path-pattern\">path pattern</a> between the <code class=\"language-text\">/</code> characters. For example, \"/users/123\" has two segments.</li>\n<li><strong>Path Pattern</strong> - These look like URLs but can have special characters for matching URLs to routes, like <strong>dynamic segments</strong> (<code class=\"language-text\">\"/users/:userId\"</code>) or <strong>star segments</strong> (<code class=\"language-text\">\"/docs/*\"</code>). They aren't URLs, they're patterns that React Router will match.</li>\n<li><strong>Dynamic Segment</strong> - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern <code class=\"language-text\">/users/:userId</code> will match URLs like <code class=\"language-text\">/users/123</code></li>\n<li><strong>URL Params</strong> - The parsed values from the URL that matched a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#dynamic-segment\">dynamic segment</a>.</li>\n<li><strong>Router</strong> - Stateful, top-level component that makes all the other components and hooks work.</li>\n<li><strong>Route Config</strong> - A tree of <strong>routes objects</strong> that will be ranked and matched (with nesting) against the current location to create a branch of <strong>route matches</strong>.</li>\n<li><strong>Route</strong> - An object or Route Element typically with a shape of <code class=\"language-text\">{ path, element }</code> or <code class=\"language-text\">&lt;Route path element></code>. The <code class=\"language-text\">path</code> is a path pattern. When the path pattern matches the current URL, the element will be rendered.</li>\n<li><strong>Route Element</strong> - Or <code class=\"language-text\">&lt;Route></code>. This element's props are read to create a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route\">route</a> by <code class=\"language-text\">&lt;Routes></code>, but otherwise does nothing.</li>\n<li><strong>Nested Routes</strong> - Because routes can have children and each route defines a portion of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> through <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#segment\">segments</a>, a single URL can match multiple routes in a nested \"branch\" of the tree. This enables automatic layout nesting through <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#outlet\">outlet</a>, <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#relative-links\">relative links</a>, and more.</li>\n<li><strong>Relative links</strong> - Links that don't start with <code class=\"language-text\">/</code> will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.</li>\n<li><strong>Match</strong> - An object that holds information when a route matches the URL, like the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url-params\">url params</a> and pathname that matched.</li>\n<li><strong>Matches</strong> - An array of routes (or branch of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a>) that matches the current <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a>. This structure enables <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#nested-routes\">nested routes</a>.</li>\n<li><strong>Parent Route</strong> - A route with child routes.</li>\n<li><strong>Outlet</strong> - A component that renders the next match in a set of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a>.</li>\n<li><strong>Index Route</strong> - A child route with no path that renders in the parent's <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#outlet\">outlet</a> at the parent's <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>.</li>\n<li><strong>Layout Route</strong> - A <strong>parent route</strong> without a path, used exclusively for grouping child routes inside a specific layout.</li>\n</ul>\n<h2>History and Locations</h2>\n<p>Before React Router can do anything, it has to be able to subscribe to changes in the browser <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a>.</p>\n<p>Browsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.</p>\n<p>For example, consider the user:</p>\n<ol>\n<li>clicks a link to <code class=\"language-text\">/dashboard</code></li>\n<li>clicks a link to <code class=\"language-text\">/accounts</code></li>\n<li>clicks a link to <code class=\"language-text\">/customers/123</code></li>\n<li>clicks the back button</li>\n<li>clicks a link to <code class=\"language-text\">/dashboard</code></li>\n</ol>\n<p>The history stack will change as follows where <strong>bold</strong> entries denote the current <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>:</p>\n<ol>\n<li><strong><code class=\"language-text\">/dashboard</code></strong></li>\n<li><code class=\"language-text\">/dashboard</code>, <strong><code class=\"language-text\">/accounts</code></strong></li>\n<li><code class=\"language-text\">/dashboard</code>, <code class=\"language-text\">/accounts</code>, <strong><code class=\"language-text\">/customers/123</code></strong></li>\n<li><code class=\"language-text\">/dashboard</code>, <strong><code class=\"language-text\">/accounts</code></strong>, <code class=\"language-text\">/customers/123</code></li>\n<li><code class=\"language-text\">/dashboard</code>, <code class=\"language-text\">/accounts</code>, <strong><code class=\"language-text\">/dashboard</code></strong></li>\n</ol>\n<h3>History Object</h3>\n<p>With <strong>client side routing</strong>, developers are able to manipulate the browser <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a> programmatically. For example, we can write some code like this to change the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> without the browsers default behavior of making a request to the server:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;a\n  href=\"/contact\"\n  onClick={(event) => {\n    // stop the browser from changing the URL and requesting the new document\n    event.preventDefault();\n    // push an entry into the browser history stack and change the URL\n    window.history.pushState({}, undefined, \"/contact\");\n  }}\n/></code></pre></div>\n<p>For illustration only, don't use <code class=\"language-text\">window.history.pushState</code> directly in React Router</p>\n<p>This code changes the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to \"listen to the URL\" and subscribe to changes like this.</p>\n<p>Well, that's not totally true. We can listen for changes to the URL via <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-actions\">pop</a> events:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">window.addEventListener(\"popstate\", () => {\n  // URL changed!\n});</code></pre></div>\n<p>But that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called <code class=\"language-text\">window.history.pushState</code> or <code class=\"language-text\">window.history.replaceState</code>.</p>\n<p>That's where a React Router specific <code class=\"language-text\">history</code> object comes into play. It provides a way to \"listen for <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>\" changes whether the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-actions\">history action</a> is <strong>push</strong>, <strong>pop</strong>, or <strong>replace</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let history = createBrowserHistory();\nhistory.listen(({ location, action }) => {\n  // this is called whenever new locations come in\n  // the action is POP, PUSH, or REPLACE\n});</code></pre></div>\n<p>Apps don't need to set up their own history objects--that's job of <code class=\"language-text\">&lt;Router></code>. It sets up one of these objects, subscribe to changes in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a>, and finally updates its state when the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a <code class=\"language-text\">location</code>, everything else works from that single object.</p>\n<h3>Locations</h3>\n<p>The browser has a location object on <code class=\"language-text\">window.location</code>. It tells you information about the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> but also has some methods to change it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">window.location.pathname; // /getting-started/concepts/\nwindow.location.hash; // #location\nwindow.location.reload(); // force a refresh w/ the server\n// and a lot more</code></pre></div>\n<p>For illustration. You don't typically work with <code class=\"language-text\">window.location</code> in a React Router app</p>\n<p>Instead of using <code class=\"language-text\">window.location</code>, React Router has the concept of a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> that's patterned after <code class=\"language-text\">window.location</code> but is much simpler. It looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram\",\n  hash: \"#menu\",\n  state: null,\n  key: \"aefz24ie\"\n}</code></pre></div>\n<p>The first three: <code class=\"language-text\">{ pathname, search, hash }</code> are exactly like <code class=\"language-text\">window.location</code>. If you just add up the three you'll get the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> the user sees in the browser:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">location.pathname + location.search + location.hash;\n// /bbq/pig-pickins?campaign=instagram#menu</code></pre></div>\n<p>The last two, <code class=\"language-text\">{ state, key }</code>, are React Router specific.</p>\n<p><strong>Location Pathname</strong></p>\n<p>This is the part of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> after the origin, so for <code class=\"language-text\">https://example.com/teams/hotspurs</code> the pathname is <code class=\"language-text\">/teams/hostspurs</code>. This is the only part of the location that routes match against.</p>\n<p><strong>Location Search</strong></p>\n<p>People use a lot of different terms for this part of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>:</p>\n<ul>\n<li>location search</li>\n<li>search params</li>\n<li>URL search params</li>\n<li>query string</li>\n</ul>\n<p>In React Router we call it the \"location search\". However, location search is a serialized version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\"><code class=\"language-text\">URLSearchParams</code></a>. So sometimes we might call it \"URL search params\" as well.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// given a location like this:\nlet location = {\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram&amp;popular=true\",\n  hash: \"\",\n  state: null,\n  key: \"aefz24ie\",\n};\n\n// we can turn the location.search into URLSearchParams\nlet params = new URLSearchParams(location.search);\nparams.get(\"campaign\"); // \"instagram\"\nparams.get(\"popular\"); // \"true\"\nparams.toString(); // \"campaign=instagram&amp;popular=true\",</code></pre></div>\n<p>When being precise, refer to the serialized string version as \"search\" and the parsed version as \"search params\", but it's common to use the terms interchangeably when precision isn't important.</p>\n<p><strong>Location Hash</strong></p>\n<p>Hashes in URLs indicate a scroll position <em>on the current page</em>. Before the <code class=\"language-text\">window.history.pushState</code> API was introduced, web developers did client side routing exclusively with the hash portion of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>, it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.</p>\n<p><strong>Location State</strong></p>\n<p>You may have wondered why the <code class=\"language-text\">window.history.pushState()</code> API is called \"push state\". State? Aren't we just changing the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>? Shouldn't it be <code class=\"language-text\">history.push</code>? Well, we weren't in the room when the API was designed, so we're not sure why \"state\" was the focus, but it is a cool feature of browsers nonetheless.</p>\n<p>Browsers let us persist information about a transition by passing a value to <code class=\"language-text\">pushState</code>. When the user clicks back, the value on <code class=\"language-text\">history.state</code> changes to whatever was \"pushed\" before.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">window.history.pushState(\"look ma!\", undefined, \"/contact\");\nwindow.history.state; // \"look ma!\"\n// user clicks back\nwindow.history.state; // undefined\n// user clicks forward\nwindow.history.state; // \"look ma!\"</code></pre></div>\n<p>For illustration. You don't read <code class=\"language-text\">history.state</code> directly in React Router apps</p>\n<p>React Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the <code class=\"language-text\">location</code> instead of <code class=\"language-text\">history</code>.</p>\n<p>You can think about <code class=\"language-text\">location.state</code> just like <code class=\"language-text\">location.hash</code> or <code class=\"language-text\">location.search</code> except instead of putting the values in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> it's hidden--like a super secret piece of the URL only the programmer knows about.</p>\n<p>A couple of great use-cases for location state are:</p>\n<ul>\n<li>Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).</li>\n<li>Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.</li>\n</ul>\n<p>You set location state in two ways: on <code class=\"language-text\">&lt;Link></code> or <code class=\"language-text\">navigate</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Link to=\"/pins/123\" state={{ fromDashboard: true }} />;\n\nlet navigate = useNavigate();\nnavigate(\"/users/123\", { state: partialUser });</code></pre></div>\n<p>And on the next page you can access it with <code class=\"language-text\">useLocation</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let location = useLocation();\nlocation.state;</code></pre></div>\n<p>Location state values will get serialized, so something like <code class=\"language-text\">new Date()</code> will be turned into a string.</p>\n<p><strong>Location Key</strong></p>\n<p>Each location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, <code class=\"language-text\">new Map()</code>, or even <code class=\"language-text\">locationStorage</code>.</p>\n<p>For example, a very basic client side data cache could store values by location key (and the fetch <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>) and skip fetching the data when the user clicks back into it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let cache = new Map();\n\nfunction useFakeFetch(URL) {\n  let location = useLocation();\n  let cacheKey = location.key + URL;\n  let cached = cache.get(cacheKey);\n\n  let [data, setData] = useState(() => {\n    // initialize from the cache\n    return cached || null;\n  });\n\n  let [state, setState] = useState(() => {\n    // avoid the fetch if cached\n    return cached ? \"done\" : \"loading\";\n  });\n\n  useEffect(() => {\n    if (state === \"loading\") {\n      let controller = new AbortController();\n      fetch(URL, { signal: controller.signal })\n        .then((res) => res.json())\n        .then((data) => {\n          if (controller.signal.aborted) return;\n          // set the cache\n          cache.set(cacheKey, data);\n          setData(data);\n        });\n      return () => controller.abort();\n    }\n  }, [state, cacheKey]);\n\n  useEffect(() => {\n    setState(\"loading\");\n  }, [URL]);\n\n  return data;\n}</code></pre></div>\n<h2>Matching</h2>\n<p>On the initial render, and when the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a> changes, React Router will match the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> against your <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a> to come up with a set of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a> to render.</p>\n<h3>Defining Routes</h3>\n<p>A route config is a tree of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route\">routes</a> that looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Routes>\n  &lt;Route path=\"/\" element={&lt;App />}>\n    &lt;Route index element={&lt;Home />} />\n    &lt;Route path=\"teams\" element={&lt;Teams />}>\n      &lt;Route path=\":teamId\" element={&lt;Team />} />\n      &lt;Route path=\":teamId/edit\" element={&lt;EditTeam />} />\n      &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n      &lt;Route index element={&lt;LeagueStandings />} />\n    &lt;/Route>\n  &lt;/Route>\n  &lt;Route element={&lt;PageLayout />}>\n    &lt;Route path=\"/privacy\" element={&lt;Privacy />} />\n    &lt;Route path=\"/tos\" element={&lt;Tos />} />\n  &lt;/Route>\n  &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n&lt;/Routes></code></pre></div>\n<p>The <code class=\"language-text\">&lt;Routes></code> component recurses through its <code class=\"language-text\">props.children</code>, strips their props, and generates an object like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let routes = [\n  {\n    element: &lt;App />,\n    path: \"/\",\n    children: [\n      {\n        index: true,\n        element: &lt;Home />,\n      },\n      {\n        path: \"teams\",\n        element: &lt;Teams />,\n        children: [\n          {\n            index: true,\n            element: &lt;LeagueStandings />,\n          },\n          {\n            path: \":teamId\",\n            element: &lt;Team />,\n          },\n          {\n            path: \":teamId/edit\",\n            element: &lt;EditTeam />,\n          },\n          {\n            path: \"new\",\n            element: &lt;NewTeamForm />,\n          },\n        ],\n      },\n    ],\n  },\n  {\n    element: &lt;PageLayout />,\n    children: [\n      {\n        element: &lt;Privacy />,\n        path: \"/privacy\",\n      },\n      {\n        element: &lt;Tos />,\n        path: \"/tos\",\n      },\n    ],\n  },\n  {\n    element: &lt;Contact />,\n    path: \"/contact-us\",\n  },\n];</code></pre></div>\n<p>In fact, instead of <code class=\"language-text\">&lt;Routes></code> you can use the hook <code class=\"language-text\">useRoutes(routesGoHere)</code> instead. That's all <code class=\"language-text\">&lt;Routes></code> is doing.</p>\n<p>As you can see, routes can define multiple <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#segment\">segments</a> like <code class=\"language-text\">:teamId/edit</code>, or just one like <code class=\"language-text\">:teamId</code>. All of the segments down a branch of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a> are added together to create a final <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#path-pattern\">path pattern</a> for a route.</p>\n<h3>Match Params</h3>\n<p>Note the <code class=\"language-text\">:teamId</code> segments. This is what we call a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#dynamic-segment\">dynamic segment</a> of the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#path-pattern\">path pattern</a>, meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for <code class=\"language-text\">:teamId</code>. Both <code class=\"language-text\">/teams/123</code> or <code class=\"language-text\">/teams/cupcakes</code> will match. We call the parsed values <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url-params\">URL params</a>. So in this case our <code class=\"language-text\">teamId</code> param would be <code class=\"language-text\">\"123\"</code> or <code class=\"language-text\">\"cupcakes\"</code>. We'll see how to use them in your app in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#rendering\">Rendering</a> section.</p>\n<h3>Ranking Routes</h3>\n<p>If we add up all the segments of all the branches of our <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a>, we end up with the following path patterns that our app responds to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[\n  \"/\",\n  \"/teams\",\n  \"/teams/:teamId\",\n  \"/teams/:teamId/edit\",\n  \"/teams/new\",\n  \"/privacy\",\n  \"/tos\",\n  \"/contact-us\",\n];</code></pre></div>\n<p>Now this is where things get really interesting. Consider the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> <code class=\"language-text\">/teams/new</code>. Which pattern in that list matches the URL?</p>\n<p>That's right, two of them!</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/teams/new\n/teams/:teamId</code></pre></div>\n<p>React Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match <code class=\"language-text\">/</code> and render the <code class=\"language-text\">&lt;Home/></code> component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.</p>\n<p>Looking at those patterns, you intuitively know that we want <code class=\"language-text\">/teams/new</code> to match the URL <code class=\"language-text\">/teams/new</code>. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.</p>\n<h3>Pathless Routes</h3>\n<p>You may have noticed the weird routes from earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Route index element={&lt;Home />} />\n&lt;Route index element={&lt;LeagueStandings />} />\n&lt;Route element={&lt;PageLayout />} /></code></pre></div>\n<p>They don't even have a path, how can they be a route? This is where the word \"route\" in React Router is used pretty loosely. <code class=\"language-text\">&lt;Home/></code> and <code class=\"language-text\">&lt;LeagueStandings/></code> are <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#index-route\">index routes</a> and <code class=\"language-text\">&lt;PageLayout/></code> is a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#layout-route\">layout route</a>. We'll discuss how they work in the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#rendering\">Rendering</a> section. Neither really has much to do with matching.</p>\n<h3>Route Matches</h3>\n<p>When a route matches the URL, it's represented by a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">match</a> object. A match for <code class=\"language-text\">&lt;Route path=\":teamId\" element={&lt;Team/>}/></code> would look something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  pathname: \"/teams/firebirds\",\n  params: {\n    teamId: \"firebirds\"\n  },\n  route: {\n    element: &lt;Team />,\n    path: \":teamId\"\n  }\n}</code></pre></div>\n<p><code class=\"language-text\">pathname</code> holds the portion of the URL that matched this route (in our case it's all of it). <code class=\"language-text\">params</code> holds the parsed values from any <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#dynamic-segment\">dynamic segments</a> that matched. Note that the param's object keys map directly to the name of the segment: <code class=\"language-text\">:teamId</code> becomes <code class=\"language-text\">params.teamId</code>.</p>\n<p>Because our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL <code class=\"language-text\">/teams/firebirds</code>, it would be the following route branch:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Routes>\n  &lt;Route path=\"/\" element={&lt;App />}>\n    &lt;Route index element={&lt;Home />} />\n    &lt;Route path=\"teams\" element={&lt;Teams />}>\n      &lt;Route path=\":teamId\" element={&lt;Team />} />\n      &lt;Route path=\":teamId/edit\" element={&lt;EditTeam />} />\n      &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n      &lt;Route index element={&lt;LeagueStandings />} />\n    &lt;/Route>\n  &lt;/Route>\n  &lt;Route element={&lt;PageLayout />}>\n    &lt;Route path=\"/privacy\" element={&lt;Privacy />} />\n    &lt;Route path=\"/tos\" element={&lt;Tos />} />\n  &lt;/Route>\n  &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n&lt;/Routes></code></pre></div>\n<p>React Router will create an array of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a> from these routes and the url so it can render a nested UI that matches the route nesting.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[\n  {\n    pathname: \"/\",\n    params: null,\n    route: {\n      element: &lt;App />,\n      path: \"/\",\n    },\n  },\n  {\n    pathname: \"/teams\",\n    params: null,\n    route: {\n      element: &lt;Teams />,\n      path: \"teams\",\n    },\n  },\n  {\n    pathname: \"/teams/firebirds\",\n    params: {\n      teamId: \"firebirds\",\n    },\n    route: {\n      element: &lt;Team />,\n      path: \":teamId\",\n    },\n  },\n];</code></pre></div>\n<h2>Rendering</h2>\n<p>The final concept is rendering. Consider that the entry to your app looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ReactDOM.render(\n  &lt;BrowserRouter>\n    &lt;Routes>\n      &lt;Route path=\"/\" element={&lt;App />}>\n        &lt;Route index element={&lt;Home />} />\n        &lt;Route path=\"teams\" element={&lt;Teams />}>\n          &lt;Route path=\":teamId\" element={&lt;Team />} />\n          &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n          &lt;Route index element={&lt;LeagueStandings />} />\n        &lt;/Route>\n      &lt;/Route>\n      &lt;Route element={&lt;PageLayout />}>\n        &lt;Route path=\"/privacy\" element={&lt;Privacy />} />\n        &lt;Route path=\"/tos\" element={&lt;Tos />} />\n      &lt;/Route>\n      &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n    &lt;/Routes>\n  &lt;/BrowserRouter>,\n  document.getElementById(\"root\")\n);</code></pre></div>\n<p>Let's use the <code class=\"language-text\">/teams/firebirds</code> URL as an example again. <code class=\"language-text\">&lt;Routes></code> will match the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> to your <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a>, get a set of <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a>, and then render a React element tree like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;App>\n  &lt;Teams>\n    &lt;Team />\n  &lt;/Teams>\n&lt;/App></code></pre></div>\n<p>Each match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.</p>\n<h3>Outlets</h3>\n<p>This nested element tree won't happen automatically. <code class=\"language-text\">&lt;Routes></code> will render the first match's element for you (In our case that's <code class=\"language-text\">&lt;App/></code>). The next match's element is <code class=\"language-text\">&lt;Teams></code>. In order to render that, <code class=\"language-text\">App</code> needs to render an <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#outlet\">outlet</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function App() {\n  return (\n    &lt;div>\n      &lt;GlobalNav />\n      &lt;Outlet />\n      &lt;GlobalFooter />\n    &lt;/div>\n  );\n}</code></pre></div>\n<p>The <code class=\"language-text\">Outlet</code> component will always render the next match. That means <code class=\"language-text\">&lt;Teams></code> also needs an outlet to render <code class=\"language-text\">&lt;Team/></code>.</p>\n<p>If the URL were <code class=\"language-text\">/contact-us</code>, the element tree would change to:</p>\n<p>Because the contact form is not under the main <code class=\"language-text\">&lt;App></code> route.</p>\n<p>If the URL were <code class=\"language-text\">/teams/firebirds/edit</code>, the element tree would change to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;App>\n  &lt;Teams>\n    &lt;EditTeam />\n  &lt;/Teams>\n&lt;/App></code></pre></div>\n<p>The outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.</p>\n<h3>Index Routes</h3>\n<p>Remember the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a> for <code class=\"language-text\">/teams</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Route path=\"teams\" element={&lt;Teams />}>\n  &lt;Route path=\":teamId\" element={&lt;Team />} />\n  &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n  &lt;Route index element={&lt;LeagueStandings />} />\n&lt;/Route></code></pre></div>\n<p>If the URL were <code class=\"language-text\">/teams/firebirds</code>, the element tree would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;App>\n  &lt;Teams>\n    &lt;Team />\n  &lt;/Teams>\n&lt;/App></code></pre></div>\n<p>But if the URL were <code class=\"language-text\">/teams</code>, the element tree would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;App>\n  &lt;Teams>\n    &lt;LeagueStandings />\n  &lt;/Teams>\n&lt;/App></code></pre></div>\n<p>League standings? How the heck did <code class=\"language-text\">&lt;Route index element={&lt;LeagueStandings>}/></code> pop in there? It doesn't even have a path! The reason is that it's an <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#index-route\">index route</a>. Index routes render in their parent route's <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#outlet\">outlet</a> at the parent route's path.</p>\n<p>Think of it this way, if you're not at one of the child routes' paths, the <code class=\"language-text\">&lt;Outlet></code> will render nothing in the UI:</p>\n<p>If all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.</p>\n<p>Another way to think of an index route is that it's the default child route when the parent matches but none of its children do.</p>\n<p>Depending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want index route to fill the space when the user hasn't clicked one of the items yet.</p>\n<h3>Layout Routes</h3>\n<p>Here's a part of our route config we haven't matched yet: <code class=\"language-text\">/privacy</code>. Let's look at the route config again, highlighting the matched routes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Routes>\n  &lt;Route path=\"/\" element={&lt;App />}>\n    &lt;Route index element={&lt;Home />} />\n    &lt;Route path=\"teams\" element={&lt;Teams />}>\n      &lt;Route path=\":teamId\" element={&lt;Team />} />\n      &lt;Route path=\":teamId/edit\" element={&lt;EditTeam />} />\n      &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n      &lt;Route index element={&lt;LeagueStandings />} />\n    &lt;/Route>\n  &lt;/Route>\n  &lt;Route element={&lt;PageLayout />}>\n    &lt;Route path=\"/privacy\" element={&lt;Privacy />} />\n    &lt;Route path=\"/tos\" element={&lt;Tos />} />\n  &lt;/Route>\n  &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n&lt;/Routes></code></pre></div>\n<p>And the resulting element tree rendered will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;App>\n  &lt;PageLayout>\n    &lt;Privacy />\n  &lt;/PageLayout>\n&lt;/App></code></pre></div>\n<p>The <code class=\"language-text\">PageLayout</code> route is admittedly weird. We call it a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#layout-route\">layout route</a> because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:</p>\n<p>You can do it like this, but we recommend using a layout route</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Routes>\n  &lt;Route path=\"/\" element={&lt;App />}>\n    &lt;Route index element={&lt;Home />} />\n    &lt;Route path=\"teams\" element={&lt;Teams />}>\n      &lt;Route path=\":teamId\" element={&lt;Team />} />\n      &lt;Route path=\":teamId/edit\" element={&lt;EditTeam />} />\n      &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n      &lt;Route index element={&lt;LeagueStandings />} />\n    &lt;/Route>\n  &lt;/Route>\n  &lt;Route\n    path=\"/privacy\"\n    element={\n      &lt;PageLayout>\n        &lt;Privacy />\n      &lt;/PageLayout>\n    }\n  />\n  &lt;Route\n    path=\"/tos\"\n    element={\n      &lt;PageLayout>\n        &lt;Tos />\n      &lt;/PageLayout>\n    }\n  />\n  &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n&lt;/Routes></code></pre></div>\n<p>So, yeah, the semantics of a layout \"route\" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.</p>\n<h2>Navigating</h2>\n<p>When the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a> changes we call that a \"navigation\". There are two ways to navigate in React Router:</p>\n<ul>\n<li><code class=\"language-text\">&lt;Link></code></li>\n<li><code class=\"language-text\">navigate</code></li>\n</ul>\n<h3>Link</h3>\n<p>This is the primary means of navigation. Rendering a <code class=\"language-text\">&lt;Link></code> allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history\">history</a> to push a new entry into the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history-stack\">history stack</a>. The <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> changes and the new <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a> will render.</p>\n<p>However, links are accessible in that they:</p>\n<ul>\n<li>Still render a <code class=\"language-text\">&lt;a href></code> so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)</li>\n<li>Don't prevent the browser's default behavior if it's a right click or command/control click to \"open in new tab\"</li>\n</ul>\n<p><a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#nested-routes\">Nested routes</a> aren't just about rendering layouts; they also enable \"relative links\". Consider our <code class=\"language-text\">teams</code> route from before:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Route path=\"teams\" element={&lt;Teams />}>\n  &lt;Route path=\":teamId\" element={&lt;Team />} />\n&lt;/Route></code></pre></div>\n<p>The <code class=\"language-text\">&lt;Teams></code> component can render links like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Link to=\"psg\" />\n&lt;Link to=\"new\" /></code></pre></div>\n<p>The full path it links to will be <code class=\"language-text\">/teams/psg</code> and <code class=\"language-text\">/teams/new</code>. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#segment\">segment</a> deeper. You can rearrange your whole <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a> and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.</p>\n<h3>Navigate Function</h3>\n<p>This function is returned from the <code class=\"language-text\">useNavigate</code> hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let navigate = useNavigate();\nuseEffect(() => {\n  setTimeout(() => {\n    navigate(\"/logout\");\n  }, 30000);\n}, []);</code></pre></div>\n<p>Or after a form is submitted:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;form onSubmit={event => {\n  event.preventDefault();\n  let data = new FormData(event.target)\n  let urlEncoded = new URLSearchParams(data)\n  navigate(\"/create\", { state: urlEncoded })\n}}></code></pre></div>\n<p>Like <code class=\"language-text\">Link</code>, <code class=\"language-text\">navigate</code> works with nested \"to\" values as well.</p>\n<p>You should have a good reason to use <code class=\"language-text\">navigate</code> instead of <code class=\"language-text\">&lt;Link></code>. This makes us very sad:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;li onClick={() => navigate(\"/somewhere\")} /></code></pre></div>\n<p>Aside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.</p>\n<h2>Data Access</h2>\n<p>Finally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let location = useLocation();\nlet urlParams = useParams();\nlet [urlSearchParams] = useSearchParams();</code></pre></div>\n<h2>Review</h2>\n<p>Let's put it all together from the top!</p>\n<ol>\n<li>You render your app:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   ReactDOM.render(\n     &lt;BrowserRouter>\n       &lt;Routes>\n         &lt;Route path=\"/\" element={&lt;App />}>\n           &lt;Route index element={&lt;Home />} />\n           &lt;Route path=\"teams\" element={&lt;Teams />}>\n             &lt;Route path=\":teamId\" element={&lt;Team />} />\n             &lt;Route path=\"new\" element={&lt;NewTeamForm />} />\n             &lt;Route index element={&lt;LeagueStandings />} />\n           &lt;/Route>\n         &lt;/Route>\n         &lt;Route element={&lt;PageLayout />}>\n           &lt;Route path=\"/privacy\" element={&lt;Privacy />} />\n           &lt;Route path=\"/tos\" element={&lt;Tos />} />\n         &lt;/Route>\n         &lt;Route path=\"contact-us\" element={&lt;Contact />} />\n       &lt;/Routes>\n     &lt;/BrowserRouter>,\n     document.getElementById(\"root\")\n   );</code></pre></div>\n<ol start=\"2\">\n<li><code class=\"language-text\">&lt;BrowserRouter></code> creates a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history\">history</a>, puts the initial <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a> in to state, and subscribes to the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#url\">URL</a>.</li>\n<li><code class=\"language-text\">&lt;Routes></code> recurses it's <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#child-route\">child routes</a> to build a <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#route-config\">route config</a>, matches those routes against the <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#location\">location</a>, creates some route <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a>, and renders the first match's route element.</li>\n<li>You render an <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#outlet\"><code class=\"language-text\">&lt;Outlet/></code></a> in each <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#parent-route\">parent route</a>.</li>\n<li>The outlets render the next match in the route <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#match\">matches</a>.</li>\n<li>The user clicks a link</li>\n<li>The link calls <code class=\"language-text\">navigate()</code></li>\n<li>The <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts#history\">history</a> changes the URL and notifies <code class=\"language-text\">&lt;BrowserRouter></code>.</li>\n<li><code class=\"language-text\">&lt;BrowserRouter></code> rerenders, start over at (2)!</li>\n</ol>\n<p>That's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.</p>\n<p>Url: <a href=\"https://reactrouter.com/docs/en/v6/getting-started/concepts\">https://reactrouter.com/docs/en/v6/getting-started/concepts</a></p>"}