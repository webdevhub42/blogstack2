{"expireTime":9007200911206587000,"key":"transformer-remark-markdown-html-e11bb1ee6197d463626f10b795215245-gatsby-remark-prismjs-","val":"<h1>Array.prototype.every()</h1>\n<p>The <code class=\"language-text\">every()</code> method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p>\n<h2>Syntax</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Arrow function\nevery((element) => { ... } )\nevery((element, index) => { ... } )\nevery((element, index, array) => { ... } )\n\n// Callback function\nevery(callbackFn)\nevery(callbackFn, thisArg)\n\n// Inline callback function\nevery(function callbackFn(element) { ... })\nevery(function callbackFn(element, index) { ... })\nevery(function callbackFn(element, index, array){ ... })\nevery(function callbackFn(element, index, array) { ... }, thisArg)</code></pre></div>\n<h3>Parameters</h3>\n<p><code class=\"language-text\">callbackFn</code>\nA function to test for each element, taking three arguments:</p>\n<p><code class=\"language-text\">element</code>\nThe current element being processed in the array.</p>\n<p><code class=\"language-text\">index</code> <span class=\"badge inline optional\">Optional</span>\nThe index of the current element being processed in the array.</p>\n<p><code class=\"language-text\">array</code> <span class=\"badge inline optional\">Optional</span>\nThe array <code class=\"language-text\">every</code> was called upon.</p>\n<p><code class=\"language-text\">thisArg</code> <span class=\"badge inline optional\">Optional</span>\nA value to use as <code class=\"language-text\">this</code> when executing <code class=\"language-text\">callbackFn</code>.</p>\n<h3>Return value</h3>\n<p><code class=\"language-text\">true</code> if the <code class=\"language-text\">callbackFn</code> function returns a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\">truthy</a> value for every array element. Otherwise, <code class=\"language-text\">false</code>.</p>\n<h2>Description</h2>\n<p>The <code class=\"language-text\">every</code> method executes the provided <code class=\"language-text\">callbackFn</code> function once for each element present in the array until it finds the one where <code class=\"language-text\">callbackFn</code> returns a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Falsy\">falsy</a> value. If such an element is found, the <code class=\"language-text\">every</code> method immediately returns <code class=\"language-text\">false</code>. Otherwise, if <code class=\"language-text\">callbackFn</code> returns a <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\">truthy</a> value for all elements, <code class=\"language-text\">every</code> returns <code class=\"language-text\">true</code>.</p>\n<p><strong>Note:</strong> Calling this method on an empty array will return <code class=\"language-text\">true</code> for any condition!</p>\n<p><code class=\"language-text\">callbackFn</code> is invoked only for array indexes which have assigned values. It is not invoked for indexes which have been deleted, or which have never been assigned values.</p>\n<p><code class=\"language-text\">callbackFn</code> is invoked with three arguments: the value of the element, the index of the element, and the Array object being traversed.</p>\n<p>If a <code class=\"language-text\">thisArg</code> parameter is provided to <code class=\"language-text\">every</code>, it will be used as callback's <code class=\"language-text\">this</code> value. Otherwise, the value <code class=\"language-text\">undefined</code> will be used as its <code class=\"language-text\">this</code> value. The <code class=\"language-text\">this</code> value ultimately observable by <code class=\"language-text\">callback</code> is determined according to <a href=\"../../operators/this\">the usual rules for determining the <code class=\"language-text\">this</code> seen by a function</a>.</p>\n<p><code class=\"language-text\">every</code> does not mutate the array on which it is called.</p>\n<p>The range of elements processed by <code class=\"language-text\">every</code> is set before the first invocation of <code class=\"language-text\">callbackFn</code>. Therefore, <code class=\"language-text\">callbackFn</code> will not run on elements that are appended to the array after the call to <code class=\"language-text\">every</code> begins. If existing elements of the array are changed, their value as passed to <code class=\"language-text\">callbackFn</code> will be the value at the time <code class=\"language-text\">every</code> visits them. Elements that are deleted are not visited.</p>\n<p><code class=\"language-text\">every</code> acts like the \"for all\" quantifier in mathematics. In particular, for an empty array, it returns <code class=\"language-text\">true</code>. (It is <a href=\"https://en.wikipedia.org/wiki/Vacuous_truth\">vacuously true</a> that all elements of the <a href=\"https://en.wikipedia.org/wiki/Empty_set#Properties\">empty set</a> satisfy any given condition.)</p>\n<h2>Polyfill</h2>\n<p><code class=\"language-text\">every</code> was added to the ECMA-262 standard in the 5<sup>th</sup> edition, and it may not be present in other implementations of the standard. You can work around this by inserting the following code at the beginning of your scripts, allowing use of <code class=\"language-text\">every</code> in implementations which do not natively support it.</p>\n<p>This algorithm is exactly the one specified in ECMA-262, 5<sup>th</sup> edition, assuming <code class=\"language-text\">Object</code> and <code class=\"language-text\">TypeError</code> have their original values, and that <code class=\"language-text\">callbackfn.call</code> evaluates to the original value of <a href=\"../function/call\"><code class=\"language-text\">Function.prototype.call</code></a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (!Array.prototype.every) {\n  Array.prototype.every = function(callbackfn, thisArg) {\n    'use strict';\n    var T, k;\n\n    if (this == null) {\n      throw new TypeError('this is null or not defined');\n    }\n\n    // 1. Let O be the result of calling ToObject passing the this\n    //    value as the argument.\n    var O = Object(this);\n\n    // 2. Let lenValue be the result of calling the Get internal method\n    //    of O with the argument \"length\".\n    // 3. Let len be ToUint32(lenValue).\n    var len = O.length >>> 0;\n\n    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.\n    if (typeof callbackfn !== 'function' &amp;&amp; Object.prototype.toString.call(callbackfn) !== '[object Function]') {\n      throw new TypeError();\n    }\n\n    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n\n    // 6. Let k be 0.\n    k = 0;\n\n    // 7. Repeat, while k &lt; len\n    while (k &lt; len) {\n\n      var kValue;\n\n      // a. Let Pk be ToString(k).\n      //   This is implicit for LHS operands of the in operator\n      // b. Let kPresent be the result of calling the HasProperty internal\n      //    method of O with argument Pk.\n      //   This step can be combined with c\n      // c. If kPresent is true, then\n      if (k in O) {\n        var testResult;\n        // i. Let kValue be the result of calling the Get internal method\n        //    of O with argument Pk.\n        kValue = O[k];\n\n        // ii. Let testResult be the result of calling the Call internal method\n        // of callbackfn with T as the this value if T is not undefined\n        // else is the result of calling callbackfn\n        // and argument list containing kValue, k, and O.\n        if(T) testResult = callbackfn.call(T, kValue, k, O);\n        else testResult = callbackfn(kValue,k,O)\n\n        // iii. If ToBoolean(testResult) is false, return false.\n        if (!testResult) {\n          return false;\n        }\n      }\n      k++;\n    }\n    return true;\n  };\n}</code></pre></div>\n<h2>Examples</h2>\n<h3>Testing size of all array elements</h3>\n<p>The following example tests whether all elements in the array are bigger than 10.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function isBigEnough(element, index, array) {\n  return element >= 10;\n}\n[12, 5, 8, 130, 44].every(isBigEnough);   // false\n[12, 54, 18, 130, 44].every(isBigEnough); // true</code></pre></div>\n<h3>Using arrow functions</h3>\n<p><a href=\"../../functions/arrow_functions\">Arrow functions</a> provide a shorter syntax for the same test.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[12, 5, 8, 130, 44].every(x => x >= 10);   // false\n[12, 54, 18, 130, 44].every(x => x >= 10); // true</code></pre></div>\n<h3>Affecting Initial Array (modifying, appending, and deleting)</h3>\n<p>The following examples tests the behavior of the <code class=\"language-text\">every</code> method when the array is modified.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// ---------------\n// Modifying items\n// ---------------\nlet arr = [1, 2, 3, 4];\narr.every( (elem, index, arr) => {\n  arr[index+1] -= 1\n  console.log(`[${arr}][${index}] -> ${elem}`)\n  return elem &lt; 2\n})\n\n// Loop runs for 3 iterations, but would\n// have run 2 iterations without any modification\n//\n// 1st iteration: [1,1,3,4][0] -> 1\n// 2nd iteration: [1,1,2,4][1] -> 1\n// 3rd iteration: [1,1,2,3][2] -> 2\n\n// ---------------\n// Appending items\n// ---------------\narr = [1, 2, 3];\narr.every( (elem, index, arr) => {\n  arr.push('new')\n  console.log(`[${arr}][${index}] -> ${elem}`)\n  return elem &lt; 4\n})\n\n// Loop runs for 3 iterations, even after appending new items\n//\n// 1st iteration: [1, 2, 3, new][0] -> 1\n// 2nd iteration: [1, 2, 3, new, new][1] -> 2\n// 3rd iteration: [1, 2, 3, new, new, new][2] -> 3\n\n// ---------------\n// Deleting items\n// ---------------\narr = [1, 2, 3, 4];\narr.every( (elem, index, arr) => {\n  arr.pop()\n  console.log(`[${arr}][${index}] -> ${elem}`)\n  return elem &lt; 4\n})\n\n// Loop runs for 2 iterations only, as the remaining\n// items are `pop()`ed off\n//\n// 1st iteration: [1,2,3][0] -> 1\n// 2nd iteration: [1,2][1] -> 2</code></pre></div>"}