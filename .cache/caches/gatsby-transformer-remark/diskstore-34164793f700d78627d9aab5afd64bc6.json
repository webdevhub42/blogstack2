{"expireTime":9007200911870455000,"key":"transformer-remark-markdown-html-e65270af25f6be8912711a5f431b5f71-gatsby-remark-prismjs-","val":"<h1>General Types</h1>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#number-string-boolean-symbol-and-object\">types</a><code class=\"language-text\">Number</code>, <code class=\"language-text\">String</code>, <code class=\"language-text\">Boolean</code>, <code class=\"language-text\">Symbol</code> and <code class=\"language-text\">Object</code></h2>\n<p>❌ <strong>Don’t</strong> ever use the types <code class=\"language-text\">Number</code>, <code class=\"language-text\">String</code>, <code class=\"language-text\">Boolean</code>, <code class=\"language-text\">Symbol</code>, or <code class=\"language-text\">Object</code> These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */function reverse(s: String): String;</code></pre></div>\n<p>✅ <strong>Do</strong> use the types <code class=\"language-text\">number</code>, <code class=\"language-text\">string</code>, <code class=\"language-text\">boolean</code>, and <code class=\"language-text\">symbol</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */function reverse(s: string): string;</code></pre></div>\n<p>Instead of <code class=\"language-text\">Object</code>, use the non-primitive <code class=\"language-text\">object</code> type (<a href=\"https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type\">added in TypeScript 2.2</a>).</p>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#generics\">Generics</a></h2>\n<p>❌ <strong>Don’t</strong> ever have a generic type which doesn’t use its type parameter. See more details in <a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot--\">TypeScript FAQ page</a>.</p>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#any\">any</a></h2>\n<p>❌ <strong>Don’t</strong> use <code class=\"language-text\">any</code> as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler <em>effectively</em> treats <code class=\"language-text\">any</code> as “please turn off type checking for this thing”. It is similar to putting an <code class=\"language-text\">@ts-ignore</code> comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as <code class=\"language-text\">any</code>, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.</p>\n<p>In cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use <a href=\"https://www.typescriptlang.org/play/#example/unknown-and-never\"><code class=\"language-text\">unknown</code></a>.</p>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#callback-types\">Callback Types</a></h2>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#return-types-of-callbacks\">Return Types of Callbacks</a></h2>\n<p>❌ <strong>Don’t</strong> use the return type <code class=\"language-text\">any</code> for callbacks whose value will be ignored:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */function fn(x: () => any) {  x();}</code></pre></div>\n<p>✅ <strong>Do</strong> use the return type <code class=\"language-text\">void</code> for callbacks whose value will be ignored:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */function fn(x: () => void) {  x();}</code></pre></div>\n<p>❔ <strong>Why:</strong> Using <code class=\"language-text\">void</code> is safer because it prevents you from accidentally using the return value of <code class=\"language-text\">x</code> in an unchecked way:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsfunction fn(x: () => void) {  var k = x(); // oops! meant to do something else  k.doSomething(); // error, but would be OK if the return type had been 'any'}</code></pre></div>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#optional-parameters-in-callbacks\">Optional Parameters in Callbacks</a></h2>\n<p>❌ <strong>Don’t</strong> use optional parameters in callbacks unless you really mean it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */interface Fetcher {  getObject(done: (data: unknown, elapsedTime?: number) => void): void;}</code></pre></div>\n<p>This has a very specific meaning: the <code class=\"language-text\">done</code> callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the <code class=\"language-text\">elapsedTime</code> parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.</p>\n<p>✅ <strong>Do</strong> write callback parameters as non-optional:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */interface Fetcher {  getObject(done: (data: unknown, elapsedTime: number) => void): void;}</code></pre></div>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#overloads-and-callbacks\">Overloads and Callbacks</a></h2>\n<p>❌ <strong>Don’t</strong> write separate overloads that differ only on callback arity:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */declare function beforeAll(action: () => void, timeout?: number): void;declare function beforeAll(  action: (done: DoneFn) => void,  timeout?: number): void;</code></pre></div>\n<p>✅ <strong>Do</strong> write a single overload using the maximum arity:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */declare function beforeAll(  action: (done: DoneFn) => void,  timeout?: number): void;</code></pre></div>\n<p>❔ <strong>Why:</strong> It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</p>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#function-overloads\">Function Overloads</a></h2>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#ordering\">Ordering</a></h2>\n<p>❌ <strong>Don’t</strong> put more general overloads before more specific overloads:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */declare function fn(x: unknown): unknown;declare function fn(x: HTMLElement): number;declare function fn(x: HTMLDivElement): string;var myElem: HTMLDivElement;var x = fn(myElem); // x: unknown, wat?</code></pre></div>\n<p>✅ <strong>Do</strong> sort overloads by putting the more general signatures after more specific signatures:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */declare function fn(x: HTMLDivElement): string;declare function fn(x: HTMLElement): number;declare function fn(x: unknown): unknown;var myElem: HTMLDivElement;var x = fn(myElem); // x: string, :)</code></pre></div>\n<p>❔ <strong>Why:</strong> TypeScript chooses the <em>first matching overload</em> when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.</p>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#use-optional-parameters\">Use Optional Parameters</a></h2>\n<p>❌ <strong>Don’t</strong> write several overloads that differ only in trailing parameters:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */interface Example {  diff(one: string): number;  diff(one: string, two: string): number;  diff(one: string, two: string, three: boolean): number;}</code></pre></div>\n<p>✅ <strong>Do</strong> use optional parameters whenever possible:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */interface Example {  diff(one: string, two?: string, three?: boolean): number;}</code></pre></div>\n<p>Note that this collapsing should only occur when all overloads have the same return type.</p>\n<p>❔ <strong>Why:</strong> This is important for two reasons.</p>\n<p>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, <em>and extraneous arguments are allowed</em>. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsfunction fn(x: (a: string, b: number, c: number) => void) {}var x: Example;// When written with overloads, OK -- used first overload// When written with optionals, correctly an errorfn(x.diff);</code></pre></div>\n<p>The second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as <code class=\"language-text\">undefined</code> in JavaScript, it’s usually fine to pass an explicit <code class=\"language-text\">undefined</code> to a function with optional arguments. This code, for example, should be OK under strict nulls:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsvar x: Example;// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'// When written with optionals, correctly OKx.diff(\"something\", true ? undefined : \"hour\");</code></pre></div>\n<h2><a href=\"https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#use-union-types\">Use Union Types</a></h2>\n<p>❌ <strong>Don’t</strong> write overloads that differ by type in only one argument position:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* WRONG */interface Moment {  utcOffset(): number;  utcOffset(b: number): Moment;  utcOffset(b: string): Moment;}</code></pre></div>\n<p>✅ <strong>Do</strong> use union types whenever possible:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ts/* OK */interface Moment {  utcOffset(): number;  utcOffset(b: number | string): Moment;}</code></pre></div>\n<p>Note that we didn’t make <code class=\"language-text\">b</code> optional here because the return types of the signatures differ.</p>\n<p>❔ <strong>Why:</strong> This is important for people who are “passing through” a value to your function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsfunction fn(x: string): void;function fn(x: number): void;function fn(x: number | string) {  // When written with separate overloads, incorrectly an error  // When written with union types, correctly OK  return moment().utcOffset(x);}</code></pre></div>"}