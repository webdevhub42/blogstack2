{"expireTime":9007200911870455000,"key":"transformer-remark-markdown-html-034957a4a2d1e3ff20edb06e33e87922-gatsby-remark-prismjs-","val":"<h1>Function.prototype.bind()</h1>\n<p>The <code class=\"language-text\">bind()</code> method creates a new function that, when called, has its <code class=\"language-text\">this</code> keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.</p>\n<h2>Syntax</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">bind(thisArg)\nbind(thisArg, arg1)\nbind(thisArg, arg1, arg2)\nbind(thisArg, arg1, ... , argN)</code></pre></div>\n<h3>Parameters</h3>\n<p><code class=\"language-text\">thisArg</code>\nThe value to be passed as the <code class=\"language-text\">this</code> parameter to the target function <code class=\"language-text\">func</code> when the bound function is called. The value is ignored if the bound function is constructed using the <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a> operator. When using <code class=\"language-text\">bind</code> to create a function (supplied as a callback) inside a <code class=\"language-text\">setTimeout</code>, any primitive value passed as <code class=\"language-text\">thisArg</code> is converted to object. If no arguments are provided to <code class=\"language-text\">bind</code>, or if the <code class=\"language-text\">thisArg</code> is <code class=\"language-text\">null</code> or <code class=\"language-text\">undefined</code>, the <code class=\"language-text\">this</code> of the executing scope is treated as the <code class=\"language-text\">thisArg</code> for the new function.</p>\n<p><code class=\"language-text\">arg1, arg2, ...argN</code> <span class=\"badge inline optional\">Optional</span>\nArguments to prepend to arguments provided to the bound function when invoking <code class=\"language-text\">func</code>.</p>\n<h3>Return value</h3>\n<p>A copy of the given function with the specified <code class=\"language-text\">this</code> value, and initial arguments (if provided).</p>\n<h2>Description</h2>\n<p>The <code class=\"language-text\">bind()</code> function creates a new <strong>bound function</strong>, which is an <em>exotic function object</em> (a term from ECMAScript 2015) that wraps the original function object. Calling the bound function generally results in the execution of its wrapped function.</p>\n<p>A bound function has the following internal properties:</p>\n<p><code class=\"language-text\">[[BoundTargetFunction]]</code>\nThe wrapped function object</p>\n<p><code class=\"language-text\">[[BoundThis]]</code>\nThe value that is always passed as <code class=\"language-text\">this</code> value when calling the wrapped function.</p>\n<p><code class=\"language-text\">[[BoundArguments]]</code>\nA list of values whose elements are used as the first arguments to any call to the wrapped function.</p>\n<p><code class=\"language-text\">[[Call]]</code>\nExecutes code associated with this object. Invoked via a function call expression. The arguments to the internal method are a <code class=\"language-text\">this</code> value and a list containing the arguments passed to the function by a call expression.</p>\n<p>When a bound function is called, it calls internal method <code class=\"language-text\">[[Call]]</code> on <code class=\"language-text\">[[BoundTargetFunction]]</code>, with following arguments <code class=\"language-text\">Call(boundThis, ...args)</code>. Where <code class=\"language-text\">boundThis</code> is <code class=\"language-text\">[[BoundThis]]</code>, <code class=\"language-text\">args</code> is <code class=\"language-text\">[[BoundArguments]]</code>, followed by the arguments passed by the function call.</p>\n<p>A bound function may also be constructed using the <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a> operator. Doing so acts as though the target function had instead been constructed. The provided <code class=\"language-text\">this</code> value is ignored, while prepended arguments are provided to the emulated function.</p>\n<h2>Examples</h2>\n<h3>Creating a bound function</h3>\n<p>The simplest use of <code class=\"language-text\">bind()</code> is to make a function that, no matter how it is called, is called with a particular <code class=\"language-text\">this</code> value.</p>\n<p>A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its <code class=\"language-text\">this</code> (e.g., by using the method in callback-based code).</p>\n<p>Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">this.x = 9;    // 'this' refers to global 'window' object here in a browser\nconst module = {\n  x: 81,\n  getX: function() { return this.x; }\n};\n\nmodule.getX();\n//  returns 81\n\nconst retrieveX = module.getX;\nretrieveX();\n//  returns 9; the function gets invoked at the global scope\n\n//  Create a new function with 'this' bound to module\n//  New programmers might confuse the\n//  global variable 'x' with module's property 'x'\nconst boundGetX = retrieveX.bind(module);\nboundGetX();\n//  returns 81</code></pre></div>\n<h3>Partially applied functions</h3>\n<p>The next simplest use of <code class=\"language-text\">bind()</code> is to make a function with pre-specified initial arguments.</p>\n<p>These arguments (if any) follow the provided <code class=\"language-text\">this</code> value and are then inserted at the start of the arguments passed to the target function, followed by whatever arguments are passed bound function at the time it is called.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n  return arg1 + arg2\n}\n\nconst list1 = list(1, 2, 3);\n//  [1, 2, 3]\n\nconst result1 = addArguments(1, 2);\n//  3\n\n// Create a function with a preset leading argument\nconst leadingThirtysevenList = list.bind(null, 37);\n\n// Create a function with a preset first argument.\nconst addThirtySeven = addArguments.bind(null, 37);\n\nconst list2 = leadingThirtysevenList();\n//  [37]\n\nconst list3 = leadingThirtysevenList(1, 2, 3);\n//  [37, 1, 2, 3]\n\nconst result2 = addThirtySeven(5);\n//  37 + 5 = 42\n\nconst result3 = addThirtySeven(5, 10);\n//  37 + 5 = 42\n//  (the second argument is ignored)</code></pre></div>\n<h3>With <code class=\"language-text\">setTimeout()</code></h3>\n<p>By default within <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout\"><code class=\"language-text\">window.setTimeout()</code></a>, the <code class=\"language-text\">this</code> keyword will be set to the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window\"><code class=\"language-text\">window</code></a> (or <code class=\"language-text\">global</code>) object. When working with class methods that require <code class=\"language-text\">this</code> to refer to class instances, you may explicitly bind <code class=\"language-text\">this</code> to the callback function, in order to maintain the instance.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function LateBloomer() {\n  this.petalCount = Math.floor(Math.random() * 12) + 1;\n}\n\n// Declare bloom after a delay of 1 second\nLateBloomer.prototype.bloom = function() {\n  window.setTimeout(this.declare.bind(this), 1000);\n};\n\nLateBloomer.prototype.declare = function() {\n  console.log(`I am a beautiful flower with ${this.petalCount} petals!`);\n};\n\nconst flower = new LateBloomer();\nflower.bloom();\n//  after 1 second, calls 'flower.declare()'</code></pre></div>\n<h3>Bound functions used as constructors</h3>\n<p><strong>Warning:</strong> This section demonstrates JavaScript capabilities and documents some edge cases of the <code class=\"language-text\">bind()</code> method.</p>\n<p>The methods shown below are not the best way to do things, and probably should not be used in any production environment.</p>\n<p>Bound functions are automatically suitable for use with the <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a> operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided <code class=\"language-text\">this</code> is ignored.</p>\n<p>However, provided arguments are still prepended to the constructor call:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function() {\n  return `${this.x},${this.y}`;\n};\n\nconst p = new Point(1, 2);\np.toString();\n// '1,2'\n\n//  not supported in the polyfill below,\n\n//  works fine with native bind:\n\nconst YAxisPoint = Point.bind(null, 0/*x*/);\n\nconst emptyObj = {};\nconst YAxisPoint = Point.bind(emptyObj, 0/*x*/);\n\nconst axisPoint = new YAxisPoint(5);\naxisPoint.toString();                    // '0,5'\n\naxisPoint instanceof Point;              // true\naxisPoint instanceof YAxisPoint;         // true\nnew YAxisPoint(17, 42) instanceof Point; // true</code></pre></div>\n<p>Note that you need not do anything special to create a bound function for use with <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a>.</p>\n<p>The corollary is that you need not do anything special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//  Example can be run directly in your JavaScript console\n//  ...continued from above\n\n//  Can still be called as a normal function\n//  (although usually this is undesired)\nYAxisPoint(13);\n\n`${emptyObj.x},${emptyObj.y}`;\n// >  '0,13'</code></pre></div>\n<p>If you wish to support the use of a bound function only using <a href=\"../../operators/new\"><code class=\"language-text\">new</code></a>, or only by calling it, the target function must enforce that restriction.</p>\n<h3>Creating shortcuts</h3>\n<p><code class=\"language-text\">bind()</code> is also helpful in cases where you want to create a shortcut to a function which requires a specific <code class=\"language-text\">this</code> value.</p>\n<p>Take <a href=\"../array/slice\"><code class=\"language-text\">Array.prototype.slice()</code></a>, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const slice = Array.prototype.slice;\n\n// ...\n\nslice.apply(arguments);</code></pre></div>\n<p>With <code class=\"language-text\">bind()</code>, this can be simplified.</p>\n<p>In the following piece of code, <code class=\"language-text\">slice()</code> is a bound function to the <a href=\"apply\"><code class=\"language-text\">apply()</code></a> function of <a href=\"../function\"><code class=\"language-text\">Function</code></a>, with the <code class=\"language-text\">this</code> value set to the <a href=\"../array/slice\"><code class=\"language-text\">slice()</code></a> function of <span class=\"page-not-created\"><code class=\"language-text\">Array.prototype</code></span>. This means that additional <code class=\"language-text\">apply()</code> calls can be eliminated:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//  same as \"slice\" in the previous example\nconst unboundSlice = Array.prototype.slice;\nconst slice = Function.prototype.apply.bind(unboundSlice);\n\n// ...\n\nslice(arguments);</code></pre></div>\n<h2>Polyfill</h2>\n<p>Because older browsers are generally also slower browsers, it is far more critical than most people recognize to create performance polyfills to make the browsing experience in outdated browsers slightly less horrible.</p>\n<p>Thus, presented below are two options for <code class=\"language-text\">Function.prototype.bind()</code> polyfills:</p>\n<ol>\n<li>The first one is much smaller and more performant, but does not work when using the <code class=\"language-text\">new</code> operator.</li>\n<li>The second one is bigger and less performant, but it permits some usage of the <code class=\"language-text\">new</code> operator on bound functions.</li>\n</ol>\n<p>Generally, in most code it's very rare to see <code class=\"language-text\">new</code> used on a bound function, so it is generally best to go with the first option.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//  Does not work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  var slice = Array.prototype.slice;\n  Function.prototype.bind = function() {\n    var thatFunc = this, thatArg = arguments[0];\n    var args = slice.call(arguments, 1);\n    if (typeof thatFunc !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - ' +\n             'what is trying to be bound is not callable');\n    }\n    return function(){\n      var funcArgs = args.concat(slice.call(arguments))\n      return thatFunc.apply(thatArg, funcArgs);\n    };\n  };\n})();</code></pre></div>\n<p>You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of <code class=\"language-text\">bind()</code> in implementations that do not natively support it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//  Yes, it does work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  var ArrayPrototypeSlice = Array.prototype.slice;\n  Function.prototype.bind = function(otherThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var baseArgs= ArrayPrototypeSlice.call(arguments, 1),\n        baseArgsLength = baseArgs.length,\n        fToBind = this,\n        fNOP    = function() {},\n        fBound  = function() {\n          baseArgs.length = baseArgsLength; // reset to default base arguments\n          baseArgs.push.apply(baseArgs, arguments);\n          return fToBind.apply(\n                 fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs\n          );\n        };\n\n    if (this.prototype) {\n      // Function.prototype doesn't have a prototype property\n      fNOP.prototype = this.prototype;\n    }\n    fBound.prototype = new fNOP();\n\n    return fBound;\n  };\n})();</code></pre></div>\n<p>Some of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:</p>\n<ul>\n<li>The partial implementation relies on <a href=\"../array/slice\"><code class=\"language-text\">Array.prototype.slice()</code></a>, <a href=\"../array/concat\"><code class=\"language-text\">Array.prototype.concat()</code></a>, <a href=\"call\"><code class=\"language-text\">Function.prototype.call()</code></a> and <a href=\"apply\"><code class=\"language-text\">Function.prototype.apply()</code></a>, built-in methods to have their original values.</li>\n<li>The partial implementation creates functions that do not have immutable \"poison pill\" <a href=\"caller\"><code class=\"language-text\">caller</code></a> and <code class=\"language-text\">arguments</code> properties that throw a <a href=\"../typeerror\"><code class=\"language-text\">TypeError</code></a> upon get, set, or deletion. (This could be added if the implementation supports <a href=\"../object/defineproperty\"><code class=\"language-text\">Object.defineProperty</code></a>, or partially implemented [without throw-on-delete behavior] if the implementation supports the <a href=\"../object/__definegetter__\"><code class=\"language-text\">__defineGetter__</code></a> and <a href=\"../object/__definesetter__\"><code class=\"language-text\">__defineSetter__</code></a> extensions.)</li>\n<li>The partial implementation creates functions that have a <code class=\"language-text\">prototype</code> property. (Proper bound functions have none.)</li>\n<li>The partial implementation creates bound functions whose <a href=\"length\"><code class=\"language-text\">length</code></a> property does not agree with that mandated by ECMA-262: it creates functions with <code class=\"language-text\">length</code> of <code class=\"language-text\">0</code>. A full implementation—depending on the length of the target function and the number of pre-specified arguments—may return a non-zero length.</li>\n<li>The partial implementation creates bound functions whose <a href=\"name\"><code class=\"language-text\">name</code></a> property is not derived from the original function name. According to ECMA-262, name of the returned bound function should be \"bound \" + name of target function (note the space character).</li>\n</ul>\n<p>If you choose to use this partial implementation, <strong>you must not rely on those cases where behavior deviates from ECMA-262, 5<sup>th</sup> edition!</strong> Thankfully, these deviations from the specification rarely (if ever) come up in most coding situations. If you do not understand any of the deviations from the specification above, then it is safe in this particular case to not worry about these noncompliant deviation details.</p>\n<p><strong>If it's absolutely necessary and performance is not a concern</strong>, a far slower (but more specification-compliant solution) can be found at <a href=\"https://github.com/Raynos/function-bind\">https://github.com/Raynos/function-bind</a>.</p>"}