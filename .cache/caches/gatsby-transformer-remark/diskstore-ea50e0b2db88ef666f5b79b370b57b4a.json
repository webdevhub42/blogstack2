{"expireTime":9007200911870455000,"key":"transformer-remark-markdown-html-95aaf336badf7daa645bd777b234f553-gatsby-remark-prismjs-","val":"<p>Regular expressions make light work of <strong>single-character delimiters</strong>, which is why it's so easy to remove markup from a string:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;[\\/]?[^>]+>)/g, '');</code></pre></div>\n<p>It's the negation in the character class that does the real work:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[^>]</code></pre></div>\n<p>Which means <em>\"anything except <code class=\"language-text\">&lt;</code>\"</em>. So the expression looks for the starting tag-delimiter and possible slash, then anything except the closing tag-delimiter, and then the delimiter itself. Easy.</p>\n<p>However comments are not so simple, because comment delimiters are comprised of <strong>more than one character</strong>. Multi-line comments in CSS and JavaScript, for example, start with <code class=\"language-text\">/*</code> and end with <code class=\"language-text\">*/</code>, but between those two delimiters there could be <strong>any number of unrelated stars</strong>.</p>\n<p>I often use multiple stars in comments, to indicate the severity of a bug I've just noticed, for example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*** this is a bug with 3-star severity ***/</code></pre></div>\n<p>But if we tried to parse that with a single negation character, it would fail:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(\\/\\*[^\\*]+\\*\\/)/g, '');</code></pre></div>\n<p>Yet it's not possible with regular expressions to say: <em>\"anything except [this sequence of characters]\"</em>, we can only say: <em>\"anything except [one of these single characters]\"</em>.</p>\n<p>So here's the regular expression we need instead:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm, '');</code></pre></div>\n<p>The expression handles unrelated characters by <strong>looking at what comes after them</strong> — stars are allowed as long as they're not followed by a slash, until we find one that is, and that's the end of the comment.</p>\n<p>So it says: \"<code class=\"language-text\">/</code> then <code class=\"language-text\">*</code> (then anything except <code class=\"language-text\">*</code> OR any number of <code class=\"language-text\">*</code> followed by anything except <code class=\"language-text\">/</code>)(and any number of instances of that) then any number of <code class=\"language-text\">*</code> then <code class=\"language-text\">/</code>\".</p>\n<p>(The syntax looks particular convoluted, because <code class=\"language-text\">*</code> and <code class=\"language-text\">/</code> are both special characters in regular expressions, so the ambiguous literal ones have to be escaped. Also note the <code class=\"language-text\">m</code> flag at the end of the expression, which means <strong>multi-line</strong>, and specifies that the regular expression should search across more than one line of text.)</p>\n<p>Using the same principle then, we can adapt the expression to search for any kind of complex delimiters. Here's another one that matches HTML comments:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;!\\-\\-([^\\-]|(\\-+[^>]))*\\-+>)/gm, '');</code></pre></div>\n<p>And here's one for <code class=\"language-text\">CDATA</code> sections:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">str = str.replace(/(&lt;\\!\\[CDATA\\[([^\\]]|(\\]+[^>]))*\\]+>)/gm, '');</code></pre></div>\n<h2>2. Using Replacement Callbacks</h2>\n<p>The <code class=\"language-text\">replace</code> function can also be <strong>passed a callback</strong> as its second parameter, and this is invaluable in cases where the replacement you want can't be described in a simple expression. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//</span>\nisocode <span class=\"token operator\">=</span> isocode<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">^([a-z]+)(\\-[a-z]+)?$</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">i</span></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">match<span class=\"token punctuation\">,</span> lang<span class=\"token punctuation\">,</span> country</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> lang<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>country <span class=\"token operator\">?</span> country<span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That example normalizes the capitalisation in language codes — so <code class=\"language-text\">\"EN\"</code> would become <code class=\"language-text\">\"en\"</code>, while <code class=\"language-text\">\"en-us\"</code> would become <code class=\"language-text\">\"en-US\"</code>.</p>\n<p>The first argument that's passed to the callback is always the complete match, then each subsequent argument corresponds with the backreferences (i.e. <code class=\"language-text\">arguments[1]</code> is what a string replacement would refer to as <code class=\"language-text\">$1</code>, and so on).</p>\n<p>So taking <code class=\"language-text\">\"en-us\"</code> as the input, we'd get the three arguments:</p>\n<ol start=\"0\">\n<li><code class=\"language-text\">\"en-us\"</code></li>\n<li><code class=\"language-text\">\"en\"</code></li>\n<li><code class=\"language-text\">\"-us\"</code></li>\n</ol>\n<p>Then all the function has to do is enforce the appropriate cases, re-combine the parts and return them. Whatever the callback returns is what the replacement itself returns.</p>\n<p>But we don't actually have to assign the return value (or return at all), and if we don't, then the original string will be unaffected. This means we can use <code class=\"language-text\">replace</code> as a <strong>general-purpose string processor</strong> — to extract data from a string without changing it.</p>\n<p>Here's another example, that combines the multi-line comment expression from the previous section, with a callback that extracts and saves the text of each comment:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let comments = [];\nstr.replace(/(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n  });</code></pre></div>\n<p>Since nothing is returned, the original string remains unchanged. Although if we wanted to extract <em>and</em> remove the comments, we could simply return and assign an empty-string:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//</span>\n<span class=\"token keyword\">let</span> comments <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nstr <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">(\\/\\*([^*]|(\\*+[^*\\/]))*\\*+\\/)</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">gm</span></span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">match</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    comments<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>3. Working With Invisible Delimiters</h2>\n<p>Extracting content is all very well when it uses standard delimiters, but what if you're using <strong>custom delimiters</strong> that only your program knows about? The problem there is that <strong>the string might already contain your delimiter</strong>, literally character for character, and then what do you?</p>\n<p>Well, recently I came up with a very cute trick, that not only avoids this problem, it's also as simple to use as the single-character class we saw at the start! The trick is to use <strong>unicode characters that the document can't contain</strong>.</p>\n<p>Originally I tried this with <em>undefined</em> characters, and that certainly worked, but it's not safe to assume that any such character will always be undefined (or that the document won't already contain it anyway). Then I discovered that Unicode actually reserves a set of code-points specifically for this kind of thing — so-called <a href=\"http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters\" title=\"Mapping of Unicode Characters (wikipedia.org)\">noncharacters</a>, which will never be used to define actual characters. A valid Unicode document is not allowed to contain noncharacters, but a program can use them internally for its own purposes.</p>\n<p>I was working on CSS processor, and I needed to remove all the comments before parsing the selectors, so they wouldn't confuse the selector-matching expressions. But they had to be replaced in the source with something that took up the same number of lines, so that the line-numbers would remain accurate. Then later they would have to be added back to the source, for final output.</p>\n<p>So first we use a regex callback to extract and save the comments. The callback returns a copy of the match in which all non-whitespace is converted to space, and which is delimited with a noncharacter either side:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let comments = [];\ncsstext = csstext.replace(/(\\/\\*([^*]|(\\*+([^*\\/])))*\\*+\\/)/gm,\n  function(match)\n  {\n    comments.push(match);\n    return '\\ufddf' + match.replace(/[\\S]/gim, ' ') + '\\ufddf';\n  });</code></pre></div>\n<p>That creates an array of comments in the same source-order as the spaces they leave behind, while the spaces themselves take-up as many lines as the original comment.</p>\n<p>Then the originals can be restored simply by replacing each delimited space with its corresponding saved comment — and since the delimiters are single characters, we only need a <strong>simple character class</strong> to match each pair:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">csstext = csstext.replace(/(\\ufddf[^\\ufddf]+\\ufddf)/gim,\n  function()\n  {\n    return comments.shift();\n  });</code></pre></div>\n<p>How easy is that!</p>"}